===== test1 =====
5
===== test2 =====
[let,max2,:,int,->,(,int,->,int,),=,fun,(,x,:,int,),:,(,int,->,int,),->,fun,(,y,:,int,),:,int,->,if,x,>,y,then,x,else,y,in,let,a,:,int,=,5,in,let,b,:,int,=,2,in,max2,(,a,),(,b,)]
===== test3 =====
let max2 : (int -> (int -> int)) = fun (x:int) : (int -> int) -> fun (y:int) : int -> if x > y then x else y in let a : int = 5 in let b : int = 2 in max2 (a) (b)
===== test4 =====
-> let max2 : (int -> (int -> int)) = fun (x:int) : (int -> int) -> fun (y:int) : int -> if x > y then x else y in let a : int = 5 in let b : int = 2 in max2 (a) (b)
-> let a : int = 5 in let b : int = 2 in fun (x:int) : (int -> int) -> fun (y:int) : int -> if x > y then x else y (a) (b)
-> let b : int = 2 in fun (x:int) : (int -> int) -> fun (y:int) : int -> if x > y then x else y (5) (b)
-> fun (x:int) : (int -> int) -> fun (y:int) : int -> if x > y then x else y (5) (2)
-> fun (y:int) : int -> if 5 > y then 5 else y (2)
-> if 5 > 2 then 5 else 2
-> if true then 5 else 2
-> 5
===== test5 =====
-6
===== test6 =====
[3,/,2,+,5,-,6,*,2]
===== test7 =====
3 / 2 + 5 - 6 * 2
===== test8 =====
-> 3 / 2 + 5 - 6 * 2
-> 1 + 5 - 6 * 2
-> 6 - 6 * 2
-> 6 - 12
-> -6
===== test9 =====
2
===== test10 =====
[if,(,true,),then,2,else,3]
===== test11 =====
if true then 2 else 3
===== test12 =====
-> if true then 2 else 3
-> 2
===== test13 =====
1
===== test14 =====
[(,if,(,3,<=,4,),then,(,if,true,then,1,else,2,),else,(,2,+,3,),)]
===== test15 =====
if 3 <= 4 then if true then 1 else 2 else 2 + 3
===== test16 =====
-> if 3 <= 4 then if true then 1 else 2 else 2 + 3
-> if true then if true then 1 else 2 else 2 + 3
-> 1
===== test17 =====
120
===== test18 =====
[let,fact,:,int,->,int,=,fix,f,(,n,:,int,),:,int,->,if,n,<=,0,then,1,else,n,*,f,(,n,-,1,),in,fact,(,5,)]
===== test19 =====
let fact : (int -> int) = fix f (n:int) : int -> if n <= 0 then 1 else n * f (n - 1) in fact (5)
===== test20 =====
-> let fact : (int -> int) = fix f (n:int) : int -> if n <= 0 then 1 else n * f (n - 1) in fact (5)
-> fix f (n:int) : int -> if n <= 0 then 1 else n * f (n - 1) (5)
-> if 5 <= 0 then 1 else 5 * fix f (n:int) : int -> if n <= 0 then 1 else n * f (n - 1) (5 - 1)
-> if false then 1 else 5 * fix f (n:int) : int -> if n <= 0 then 1 else n * f (n - 1) (5 - 1)
-> 5 * fix f (n:int) : int -> if n <= 0 then 1 else n * f (n - 1) (4)
-> 5 * if 4 <= 0 then 1 else 4 * fix f (n:int) : int -> if n <= 0 then 1 else n * f (n - 1) (4 - 1)
-> 5 * if false then 1 else 4 * fix f (n:int) : int -> if n <= 0 then 1 else n * f (n - 1) (4 - 1)
-> 5 * 4 * fix f (n:int) : int -> if n <= 0 then 1 else n * f (n - 1) (3)
-> 5 * 4 * if 3 <= 0 then 1 else 3 * fix f (n:int) : int -> if n <= 0 then 1 else n * f (n - 1) (3 - 1)
-> 5 * 4 * if false then 1 else 3 * fix f (n:int) : int -> if n <= 0 then 1 else n * f (n - 1) (3 - 1)
-> 5 * 4 * 3 * fix f (n:int) : int -> if n <= 0 then 1 else n * f (n - 1) (2)
-> 5 * 4 * 3 * if 2 <= 0 then 1 else 2 * fix f (n:int) : int -> if n <= 0 then 1 else n * f (n - 1) (2 - 1)
-> 5 * 4 * 3 * if false then 1 else 2 * fix f (n:int) : int -> if n <= 0 then 1 else n * f (n - 1) (2 - 1)
-> 5 * 4 * 3 * 2 * fix f (n:int) : int -> if n <= 0 then 1 else n * f (n - 1) (1)
-> 5 * 4 * 3 * 2 * if 1 <= 0 then 1 else 1 * fix f (n:int) : int -> if n <= 0 then 1 else n * f (n - 1) (1 - 1)
-> 5 * 4 * 3 * 2 * if false then 1 else 1 * fix f (n:int) : int -> if n <= 0 then 1 else n * f (n - 1) (1 - 1)
-> 5 * 4 * 3 * 2 * 1 * fix f (n:int) : int -> if n <= 0 then 1 else n * f (n - 1) (0)
-> 5 * 4 * 3 * 2 * 1 * if 0 <= 0 then 1 else 0 * fix f (n:int) : int -> if n <= 0 then 1 else n * f (n - 1) (0 - 1)
-> 5 * 4 * 3 * 2 * 1 * if true then 1 else 0 * fix f (n:int) : int -> if n <= 0 then 1 else n * f (n - 1) (0 - 1)
-> 5 * 4 * 3 * 2 * 1 * 1
-> 5 * 4 * 3 * 2 * 1
-> 5 * 4 * 3 * 2
-> 5 * 4 * 6
-> 5 * 24
-> 120
===== test21 =====
8
===== test22 =====
[let,m,:,(,int,list,),->,int,=,fix,f,(,n,:,int,list,),:,int,->,if,(,empty,n,),then,1,else,hd,n,*,f,(,tl,n,),in,m,(,4,::,2,::,[,],:,int,)]
===== test23 =====
let m : (int list -> int) = fix f (n:int list) : int -> if empty n then 1 else hd n * f (tl n) in m (4 :: 2 :: [] : int)
===== test24 =====
-> let m : (int list -> int) = fix f (n:int list) : int -> if empty n then 1 else hd n * f (tl n) in m (4 :: 2 :: [] : int)
-> fix f (n:int list) : int -> if empty n then 1 else hd n * f (tl n) (4 :: 2 :: [] : int)
-> if empty 4 :: 2 :: [] : int then 1 else hd 4 :: 2 :: [] : int * fix f (n:int list) : int -> if empty n then 1 else hd n * f (tl n) (tl 4 :: 2 :: [] : int)
-> if false then 1 else hd 4 :: 2 :: [] : int * fix f (n:int list) : int -> if empty n then 1 else hd n * f (tl n) (tl 4 :: 2 :: [] : int)
-> 4 * fix f (n:int list) : int -> if empty n then 1 else hd n * f (tl n) (tl 4 :: 2 :: [] : int)
-> 4 * fix f (n:int list) : int -> if empty n then 1 else hd n * f (tl n) (2 :: [] : int)
-> 4 * if empty 2 :: [] : int then 1 else hd 2 :: [] : int * fix f (n:int list) : int -> if empty n then 1 else hd n * f (tl n) (tl 2 :: [] : int)
-> 4 * if false then 1 else hd 2 :: [] : int * fix f (n:int list) : int -> if empty n then 1 else hd n * f (tl n) (tl 2 :: [] : int)
-> 4 * 2 * fix f (n:int list) : int -> if empty n then 1 else hd n * f (tl n) (tl 2 :: [] : int)
-> 4 * 2 * fix f (n:int list) : int -> if empty n then 1 else hd n * f (tl n) ([] : int)
-> 4 * 2 * if empty [] : int then 1 else hd [] : int * fix f (n:int list) : int -> if empty n then 1 else hd n * f (tl n) (tl [] : int)
-> 4 * 2 * if true then 1 else hd [] : int * fix f (n:int list) : int -> if empty n then 1 else hd n * f (tl n) (tl [] : int)
-> 4 * 2 * 1
-> 4 * 2
-> 8
===== test26 =====
3
===== test26 =====
[let,min,:,int,->,(,int,list,->,int,),=,fix,f,(,cur,:,int,),:,(,int,list,->,int,),->,fun,(,l,:,int,list,),:,int,->,if,(,empty,l,),then,cur,else,if,(,hd,l,),<,cur,then,f,(,hd,l,),(,tl,l,),else,f,(,cur,),(,tl,l,),in,min,(,100,),(,10,::,20,::,5,::,70,::,3,::,80,::,1000,::,[,],:,int,)]
===== test27 =====
let min : (int -> (int list -> int)) = fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) in min (100) (10 :: 20 :: 5 :: 70 :: 3 :: 80 :: 1000 :: [] : int)
===== test28 =====
-> let min : (int -> (int list -> int)) = fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) in min (100) (10 :: 20 :: 5 :: 70 :: 3 :: 80 :: 1000 :: [] : int)
-> fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (100) (10 :: 20 :: 5 :: 70 :: 3 :: 80 :: 1000 :: [] : int)
-> fun (l:int list) : int -> if empty l then 100 else if hd l < 100 then fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (hd l) (tl l) else fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (100) (tl l) (10 :: 20 :: 5 :: 70 :: 3 :: 80 :: 1000 :: [] : int)
-> if empty 10 :: 20 :: 5 :: 70 :: 3 :: 80 :: 1000 :: [] : int then 100 else if hd 10 :: 20 :: 5 :: 70 :: 3 :: 80 :: 1000 :: [] : int < 100 then fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (hd 10 :: 20 :: 5 :: 70 :: 3 :: 80 :: 1000 :: [] : int) (tl 10 :: 20 :: 5 :: 70 :: 3 :: 80 :: 1000 :: [] : int) else fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (100) (tl 10 :: 20 :: 5 :: 70 :: 3 :: 80 :: 1000 :: [] : int)
-> if false then 100 else if hd 10 :: 20 :: 5 :: 70 :: 3 :: 80 :: 1000 :: [] : int < 100 then fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (hd 10 :: 20 :: 5 :: 70 :: 3 :: 80 :: 1000 :: [] : int) (tl 10 :: 20 :: 5 :: 70 :: 3 :: 80 :: 1000 :: [] : int) else fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (100) (tl 10 :: 20 :: 5 :: 70 :: 3 :: 80 :: 1000 :: [] : int)
-> if 10 < 100 then fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (hd 10 :: 20 :: 5 :: 70 :: 3 :: 80 :: 1000 :: [] : int) (tl 10 :: 20 :: 5 :: 70 :: 3 :: 80 :: 1000 :: [] : int) else fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (100) (tl 10 :: 20 :: 5 :: 70 :: 3 :: 80 :: 1000 :: [] : int)
-> if true then fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (hd 10 :: 20 :: 5 :: 70 :: 3 :: 80 :: 1000 :: [] : int) (tl 10 :: 20 :: 5 :: 70 :: 3 :: 80 :: 1000 :: [] : int) else fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (100) (tl 10 :: 20 :: 5 :: 70 :: 3 :: 80 :: 1000 :: [] : int)
-> fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (10) (tl 10 :: 20 :: 5 :: 70 :: 3 :: 80 :: 1000 :: [] : int)
-> fun (l:int list) : int -> if empty l then 10 else if hd l < 10 then fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (hd l) (tl l) else fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (10) (tl l) (tl 10 :: 20 :: 5 :: 70 :: 3 :: 80 :: 1000 :: [] : int)
-> fun (l:int list) : int -> if empty l then 10 else if hd l < 10 then fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (hd l) (tl l) else fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (10) (tl l) (20 :: 5 :: 70 :: 3 :: 80 :: 1000 :: [] : int)
-> if empty 20 :: 5 :: 70 :: 3 :: 80 :: 1000 :: [] : int then 10 else if hd 20 :: 5 :: 70 :: 3 :: 80 :: 1000 :: [] : int < 10 then fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (hd 20 :: 5 :: 70 :: 3 :: 80 :: 1000 :: [] : int) (tl 20 :: 5 :: 70 :: 3 :: 80 :: 1000 :: [] : int) else fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (10) (tl 20 :: 5 :: 70 :: 3 :: 80 :: 1000 :: [] : int)
-> if false then 10 else if hd 20 :: 5 :: 70 :: 3 :: 80 :: 1000 :: [] : int < 10 then fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (hd 20 :: 5 :: 70 :: 3 :: 80 :: 1000 :: [] : int) (tl 20 :: 5 :: 70 :: 3 :: 80 :: 1000 :: [] : int) else fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (10) (tl 20 :: 5 :: 70 :: 3 :: 80 :: 1000 :: [] : int)
-> if 20 < 10 then fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (hd 20 :: 5 :: 70 :: 3 :: 80 :: 1000 :: [] : int) (tl 20 :: 5 :: 70 :: 3 :: 80 :: 1000 :: [] : int) else fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (10) (tl 20 :: 5 :: 70 :: 3 :: 80 :: 1000 :: [] : int)
-> if false then fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (hd 20 :: 5 :: 70 :: 3 :: 80 :: 1000 :: [] : int) (tl 20 :: 5 :: 70 :: 3 :: 80 :: 1000 :: [] : int) else fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (10) (tl 20 :: 5 :: 70 :: 3 :: 80 :: 1000 :: [] : int)
-> fun (l:int list) : int -> if empty l then 10 else if hd l < 10 then fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (hd l) (tl l) else fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (10) (tl l) (tl 20 :: 5 :: 70 :: 3 :: 80 :: 1000 :: [] : int)
-> fun (l:int list) : int -> if empty l then 10 else if hd l < 10 then fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (hd l) (tl l) else fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (10) (tl l) (5 :: 70 :: 3 :: 80 :: 1000 :: [] : int)
-> if empty 5 :: 70 :: 3 :: 80 :: 1000 :: [] : int then 10 else if hd 5 :: 70 :: 3 :: 80 :: 1000 :: [] : int < 10 then fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (hd 5 :: 70 :: 3 :: 80 :: 1000 :: [] : int) (tl 5 :: 70 :: 3 :: 80 :: 1000 :: [] : int) else fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (10) (tl 5 :: 70 :: 3 :: 80 :: 1000 :: [] : int)
-> if false then 10 else if hd 5 :: 70 :: 3 :: 80 :: 1000 :: [] : int < 10 then fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (hd 5 :: 70 :: 3 :: 80 :: 1000 :: [] : int) (tl 5 :: 70 :: 3 :: 80 :: 1000 :: [] : int) else fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (10) (tl 5 :: 70 :: 3 :: 80 :: 1000 :: [] : int)
-> if 5 < 10 then fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (hd 5 :: 70 :: 3 :: 80 :: 1000 :: [] : int) (tl 5 :: 70 :: 3 :: 80 :: 1000 :: [] : int) else fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (10) (tl 5 :: 70 :: 3 :: 80 :: 1000 :: [] : int)
-> if true then fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (hd 5 :: 70 :: 3 :: 80 :: 1000 :: [] : int) (tl 5 :: 70 :: 3 :: 80 :: 1000 :: [] : int) else fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (10) (tl 5 :: 70 :: 3 :: 80 :: 1000 :: [] : int)
-> fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (5) (tl 5 :: 70 :: 3 :: 80 :: 1000 :: [] : int)
-> fun (l:int list) : int -> if empty l then 5 else if hd l < 5 then fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (hd l) (tl l) else fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (5) (tl l) (tl 5 :: 70 :: 3 :: 80 :: 1000 :: [] : int)
-> fun (l:int list) : int -> if empty l then 5 else if hd l < 5 then fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (hd l) (tl l) else fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (5) (tl l) (70 :: 3 :: 80 :: 1000 :: [] : int)
-> if empty 70 :: 3 :: 80 :: 1000 :: [] : int then 5 else if hd 70 :: 3 :: 80 :: 1000 :: [] : int < 5 then fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (hd 70 :: 3 :: 80 :: 1000 :: [] : int) (tl 70 :: 3 :: 80 :: 1000 :: [] : int) else fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (5) (tl 70 :: 3 :: 80 :: 1000 :: [] : int)
-> if false then 5 else if hd 70 :: 3 :: 80 :: 1000 :: [] : int < 5 then fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (hd 70 :: 3 :: 80 :: 1000 :: [] : int) (tl 70 :: 3 :: 80 :: 1000 :: [] : int) else fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (5) (tl 70 :: 3 :: 80 :: 1000 :: [] : int)
-> if 70 < 5 then fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (hd 70 :: 3 :: 80 :: 1000 :: [] : int) (tl 70 :: 3 :: 80 :: 1000 :: [] : int) else fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (5) (tl 70 :: 3 :: 80 :: 1000 :: [] : int)
-> if false then fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (hd 70 :: 3 :: 80 :: 1000 :: [] : int) (tl 70 :: 3 :: 80 :: 1000 :: [] : int) else fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (5) (tl 70 :: 3 :: 80 :: 1000 :: [] : int)
-> fun (l:int list) : int -> if empty l then 5 else if hd l < 5 then fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (hd l) (tl l) else fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (5) (tl l) (tl 70 :: 3 :: 80 :: 1000 :: [] : int)
-> fun (l:int list) : int -> if empty l then 5 else if hd l < 5 then fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (hd l) (tl l) else fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (5) (tl l) (3 :: 80 :: 1000 :: [] : int)
-> if empty 3 :: 80 :: 1000 :: [] : int then 5 else if hd 3 :: 80 :: 1000 :: [] : int < 5 then fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (hd 3 :: 80 :: 1000 :: [] : int) (tl 3 :: 80 :: 1000 :: [] : int) else fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (5) (tl 3 :: 80 :: 1000 :: [] : int)
-> if false then 5 else if hd 3 :: 80 :: 1000 :: [] : int < 5 then fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (hd 3 :: 80 :: 1000 :: [] : int) (tl 3 :: 80 :: 1000 :: [] : int) else fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (5) (tl 3 :: 80 :: 1000 :: [] : int)
-> if 3 < 5 then fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (hd 3 :: 80 :: 1000 :: [] : int) (tl 3 :: 80 :: 1000 :: [] : int) else fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (5) (tl 3 :: 80 :: 1000 :: [] : int)
-> if true then fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (hd 3 :: 80 :: 1000 :: [] : int) (tl 3 :: 80 :: 1000 :: [] : int) else fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (5) (tl 3 :: 80 :: 1000 :: [] : int)
-> fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (3) (tl 3 :: 80 :: 1000 :: [] : int)
-> fun (l:int list) : int -> if empty l then 3 else if hd l < 3 then fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (hd l) (tl l) else fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (3) (tl l) (tl 3 :: 80 :: 1000 :: [] : int)
-> fun (l:int list) : int -> if empty l then 3 else if hd l < 3 then fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (hd l) (tl l) else fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (3) (tl l) (80 :: 1000 :: [] : int)
-> if empty 80 :: 1000 :: [] : int then 3 else if hd 80 :: 1000 :: [] : int < 3 then fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (hd 80 :: 1000 :: [] : int) (tl 80 :: 1000 :: [] : int) else fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (3) (tl 80 :: 1000 :: [] : int)
-> if false then 3 else if hd 80 :: 1000 :: [] : int < 3 then fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (hd 80 :: 1000 :: [] : int) (tl 80 :: 1000 :: [] : int) else fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (3) (tl 80 :: 1000 :: [] : int)
-> if 80 < 3 then fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (hd 80 :: 1000 :: [] : int) (tl 80 :: 1000 :: [] : int) else fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (3) (tl 80 :: 1000 :: [] : int)
-> if false then fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (hd 80 :: 1000 :: [] : int) (tl 80 :: 1000 :: [] : int) else fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (3) (tl 80 :: 1000 :: [] : int)
-> fun (l:int list) : int -> if empty l then 3 else if hd l < 3 then fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (hd l) (tl l) else fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (3) (tl l) (tl 80 :: 1000 :: [] : int)
-> fun (l:int list) : int -> if empty l then 3 else if hd l < 3 then fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (hd l) (tl l) else fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (3) (tl l) (1000 :: [] : int)
-> if empty 1000 :: [] : int then 3 else if hd 1000 :: [] : int < 3 then fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (hd 1000 :: [] : int) (tl 1000 :: [] : int) else fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (3) (tl 1000 :: [] : int)
-> if false then 3 else if hd 1000 :: [] : int < 3 then fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (hd 1000 :: [] : int) (tl 1000 :: [] : int) else fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (3) (tl 1000 :: [] : int)
-> if 1000 < 3 then fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (hd 1000 :: [] : int) (tl 1000 :: [] : int) else fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (3) (tl 1000 :: [] : int)
-> if false then fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (hd 1000 :: [] : int) (tl 1000 :: [] : int) else fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (3) (tl 1000 :: [] : int)
-> fun (l:int list) : int -> if empty l then 3 else if hd l < 3 then fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (hd l) (tl l) else fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (3) (tl l) (tl 1000 :: [] : int)
-> fun (l:int list) : int -> if empty l then 3 else if hd l < 3 then fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (hd l) (tl l) else fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (3) (tl l) ([] : int)
-> if empty [] : int then 3 else if hd [] : int < 3 then fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (hd [] : int) (tl [] : int) else fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (3) (tl [] : int)
-> if true then 3 else if hd [] : int < 3 then fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (hd [] : int) (tl [] : int) else fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (3) (tl [] : int)
-> 3
===== test29 =====
(20, 280)
===== test30 =====
[(,7,+,8,+,5,,,7,*,8,*,5,)]
===== test31 =====
(7 + 8 + 5, 7 * 8 * 5)
===== test32 =====
-> (7 + 8 + 5, 7 * 8 * 5)
-> (15 + 5, 7 * 8 * 5)
-> (20, 7 * 8 * 5)
-> (20, 56 * 5)
-> (20, 280)
===== test33 =====
(120, 3)
===== test34 =====
[(,let,fact,:,int,->,int,=,fix,f,(,n,:,int,),:,int,->,if,n,<=,0,then,1,else,n,*,f,(,n,-,1,),in,fact,(,5,),,,let,min,:,int,->,(,int,list,->,int,),=,fix,f,(,cur,:,int,),:,(,int,list,->,int,),->,fun,(,l,:,int,list,),:,int,->,if,(,empty,l,),then,cur,else,if,(,hd,l,),<,cur,then,f,(,hd,l,),(,tl,l,),else,f,(,cur,),(,tl,l,),in,min,(,100,),(,10,::,20,::,5,::,70,::,3,::,80,::,1000,::,[,],:,int,),)]
===== test35 =====
(let fact : (int -> int) = fix f (n:int) : int -> if n <= 0 then 1 else n * f (n - 1) in fact (5), let min : (int -> (int list -> int)) = fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) in min (100) (10 :: 20 :: 5 :: 70 :: 3 :: 80 :: 1000 :: [] : int))
===== test36 =====
-> (let fact : (int -> int) = fix f (n:int) : int -> if n <= 0 then 1 else n * f (n - 1) in fact (5), let min : (int -> (int list -> int)) = fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) in min (100) (10 :: 20 :: 5 :: 70 :: 3 :: 80 :: 1000 :: [] : int))
-> (fix f (n:int) : int -> if n <= 0 then 1 else n * f (n - 1) (5), let min : (int -> (int list -> int)) = fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) in min (100) (10 :: 20 :: 5 :: 70 :: 3 :: 80 :: 1000 :: [] : int))
-> (if 5 <= 0 then 1 else 5 * fix f (n:int) : int -> if n <= 0 then 1 else n * f (n - 1) (5 - 1), let min : (int -> (int list -> int)) = fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) in min (100) (10 :: 20 :: 5 :: 70 :: 3 :: 80 :: 1000 :: [] : int))
-> (if false then 1 else 5 * fix f (n:int) : int -> if n <= 0 then 1 else n * f (n - 1) (5 - 1), let min : (int -> (int list -> int)) = fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) in min (100) (10 :: 20 :: 5 :: 70 :: 3 :: 80 :: 1000 :: [] : int))
-> (5 * fix f (n:int) : int -> if n <= 0 then 1 else n * f (n - 1) (4), let min : (int -> (int list -> int)) = fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) in min (100) (10 :: 20 :: 5 :: 70 :: 3 :: 80 :: 1000 :: [] : int))
-> (5 * if 4 <= 0 then 1 else 4 * fix f (n:int) : int -> if n <= 0 then 1 else n * f (n - 1) (4 - 1), let min : (int -> (int list -> int)) = fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) in min (100) (10 :: 20 :: 5 :: 70 :: 3 :: 80 :: 1000 :: [] : int))
-> (5 * if false then 1 else 4 * fix f (n:int) : int -> if n <= 0 then 1 else n * f (n - 1) (4 - 1), let min : (int -> (int list -> int)) = fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) in min (100) (10 :: 20 :: 5 :: 70 :: 3 :: 80 :: 1000 :: [] : int))
-> (5 * 4 * fix f (n:int) : int -> if n <= 0 then 1 else n * f (n - 1) (3), let min : (int -> (int list -> int)) = fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) in min (100) (10 :: 20 :: 5 :: 70 :: 3 :: 80 :: 1000 :: [] : int))
-> (5 * 4 * if 3 <= 0 then 1 else 3 * fix f (n:int) : int -> if n <= 0 then 1 else n * f (n - 1) (3 - 1), let min : (int -> (int list -> int)) = fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) in min (100) (10 :: 20 :: 5 :: 70 :: 3 :: 80 :: 1000 :: [] : int))
-> (5 * 4 * if false then 1 else 3 * fix f (n:int) : int -> if n <= 0 then 1 else n * f (n - 1) (3 - 1), let min : (int -> (int list -> int)) = fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) in min (100) (10 :: 20 :: 5 :: 70 :: 3 :: 80 :: 1000 :: [] : int))
-> (5 * 4 * 3 * fix f (n:int) : int -> if n <= 0 then 1 else n * f (n - 1) (2), let min : (int -> (int list -> int)) = fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) in min (100) (10 :: 20 :: 5 :: 70 :: 3 :: 80 :: 1000 :: [] : int))
-> (5 * 4 * 3 * if 2 <= 0 then 1 else 2 * fix f (n:int) : int -> if n <= 0 then 1 else n * f (n - 1) (2 - 1), let min : (int -> (int list -> int)) = fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) in min (100) (10 :: 20 :: 5 :: 70 :: 3 :: 80 :: 1000 :: [] : int))
-> (5 * 4 * 3 * if false then 1 else 2 * fix f (n:int) : int -> if n <= 0 then 1 else n * f (n - 1) (2 - 1), let min : (int -> (int list -> int)) = fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) in min (100) (10 :: 20 :: 5 :: 70 :: 3 :: 80 :: 1000 :: [] : int))
-> (5 * 4 * 3 * 2 * fix f (n:int) : int -> if n <= 0 then 1 else n * f (n - 1) (1), let min : (int -> (int list -> int)) = fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) in min (100) (10 :: 20 :: 5 :: 70 :: 3 :: 80 :: 1000 :: [] : int))
-> (5 * 4 * 3 * 2 * if 1 <= 0 then 1 else 1 * fix f (n:int) : int -> if n <= 0 then 1 else n * f (n - 1) (1 - 1), let min : (int -> (int list -> int)) = fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) in min (100) (10 :: 20 :: 5 :: 70 :: 3 :: 80 :: 1000 :: [] : int))
-> (5 * 4 * 3 * 2 * if false then 1 else 1 * fix f (n:int) : int -> if n <= 0 then 1 else n * f (n - 1) (1 - 1), let min : (int -> (int list -> int)) = fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) in min (100) (10 :: 20 :: 5 :: 70 :: 3 :: 80 :: 1000 :: [] : int))
-> (5 * 4 * 3 * 2 * 1 * fix f (n:int) : int -> if n <= 0 then 1 else n * f (n - 1) (0), let min : (int -> (int list -> int)) = fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) in min (100) (10 :: 20 :: 5 :: 70 :: 3 :: 80 :: 1000 :: [] : int))
-> (5 * 4 * 3 * 2 * 1 * if 0 <= 0 then 1 else 0 * fix f (n:int) : int -> if n <= 0 then 1 else n * f (n - 1) (0 - 1), let min : (int -> (int list -> int)) = fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) in min (100) (10 :: 20 :: 5 :: 70 :: 3 :: 80 :: 1000 :: [] : int))
-> (5 * 4 * 3 * 2 * 1 * if true then 1 else 0 * fix f (n:int) : int -> if n <= 0 then 1 else n * f (n - 1) (0 - 1), let min : (int -> (int list -> int)) = fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) in min (100) (10 :: 20 :: 5 :: 70 :: 3 :: 80 :: 1000 :: [] : int))
-> (5 * 4 * 3 * 2 * 1 * 1, let min : (int -> (int list -> int)) = fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) in min (100) (10 :: 20 :: 5 :: 70 :: 3 :: 80 :: 1000 :: [] : int))
-> (5 * 4 * 3 * 2 * 1, let min : (int -> (int list -> int)) = fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) in min (100) (10 :: 20 :: 5 :: 70 :: 3 :: 80 :: 1000 :: [] : int))
-> (5 * 4 * 3 * 2, let min : (int -> (int list -> int)) = fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) in min (100) (10 :: 20 :: 5 :: 70 :: 3 :: 80 :: 1000 :: [] : int))
-> (5 * 4 * 6, let min : (int -> (int list -> int)) = fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) in min (100) (10 :: 20 :: 5 :: 70 :: 3 :: 80 :: 1000 :: [] : int))
-> (5 * 24, let min : (int -> (int list -> int)) = fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) in min (100) (10 :: 20 :: 5 :: 70 :: 3 :: 80 :: 1000 :: [] : int))
-> (120, let min : (int -> (int list -> int)) = fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) in min (100) (10 :: 20 :: 5 :: 70 :: 3 :: 80 :: 1000 :: [] : int))
-> (120, fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (100) (10 :: 20 :: 5 :: 70 :: 3 :: 80 :: 1000 :: [] : int))
-> (120, fun (l:int list) : int -> if empty l then 100 else if hd l < 100 then fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (hd l) (tl l) else fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (100) (tl l) (10 :: 20 :: 5 :: 70 :: 3 :: 80 :: 1000 :: [] : int))
-> (120, if empty 10 :: 20 :: 5 :: 70 :: 3 :: 80 :: 1000 :: [] : int then 100 else if hd 10 :: 20 :: 5 :: 70 :: 3 :: 80 :: 1000 :: [] : int < 100 then fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (hd 10 :: 20 :: 5 :: 70 :: 3 :: 80 :: 1000 :: [] : int) (tl 10 :: 20 :: 5 :: 70 :: 3 :: 80 :: 1000 :: [] : int) else fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (100) (tl 10 :: 20 :: 5 :: 70 :: 3 :: 80 :: 1000 :: [] : int))
-> (120, if false then 100 else if hd 10 :: 20 :: 5 :: 70 :: 3 :: 80 :: 1000 :: [] : int < 100 then fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (hd 10 :: 20 :: 5 :: 70 :: 3 :: 80 :: 1000 :: [] : int) (tl 10 :: 20 :: 5 :: 70 :: 3 :: 80 :: 1000 :: [] : int) else fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (100) (tl 10 :: 20 :: 5 :: 70 :: 3 :: 80 :: 1000 :: [] : int))
-> (120, if 10 < 100 then fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (hd 10 :: 20 :: 5 :: 70 :: 3 :: 80 :: 1000 :: [] : int) (tl 10 :: 20 :: 5 :: 70 :: 3 :: 80 :: 1000 :: [] : int) else fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (100) (tl 10 :: 20 :: 5 :: 70 :: 3 :: 80 :: 1000 :: [] : int))
-> (120, if true then fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (hd 10 :: 20 :: 5 :: 70 :: 3 :: 80 :: 1000 :: [] : int) (tl 10 :: 20 :: 5 :: 70 :: 3 :: 80 :: 1000 :: [] : int) else fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (100) (tl 10 :: 20 :: 5 :: 70 :: 3 :: 80 :: 1000 :: [] : int))
-> (120, fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (10) (tl 10 :: 20 :: 5 :: 70 :: 3 :: 80 :: 1000 :: [] : int))
-> (120, fun (l:int list) : int -> if empty l then 10 else if hd l < 10 then fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (hd l) (tl l) else fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (10) (tl l) (tl 10 :: 20 :: 5 :: 70 :: 3 :: 80 :: 1000 :: [] : int))
-> (120, fun (l:int list) : int -> if empty l then 10 else if hd l < 10 then fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (hd l) (tl l) else fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (10) (tl l) (20 :: 5 :: 70 :: 3 :: 80 :: 1000 :: [] : int))
-> (120, if empty 20 :: 5 :: 70 :: 3 :: 80 :: 1000 :: [] : int then 10 else if hd 20 :: 5 :: 70 :: 3 :: 80 :: 1000 :: [] : int < 10 then fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (hd 20 :: 5 :: 70 :: 3 :: 80 :: 1000 :: [] : int) (tl 20 :: 5 :: 70 :: 3 :: 80 :: 1000 :: [] : int) else fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (10) (tl 20 :: 5 :: 70 :: 3 :: 80 :: 1000 :: [] : int))
-> (120, if false then 10 else if hd 20 :: 5 :: 70 :: 3 :: 80 :: 1000 :: [] : int < 10 then fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (hd 20 :: 5 :: 70 :: 3 :: 80 :: 1000 :: [] : int) (tl 20 :: 5 :: 70 :: 3 :: 80 :: 1000 :: [] : int) else fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (10) (tl 20 :: 5 :: 70 :: 3 :: 80 :: 1000 :: [] : int))
-> (120, if 20 < 10 then fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (hd 20 :: 5 :: 70 :: 3 :: 80 :: 1000 :: [] : int) (tl 20 :: 5 :: 70 :: 3 :: 80 :: 1000 :: [] : int) else fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (10) (tl 20 :: 5 :: 70 :: 3 :: 80 :: 1000 :: [] : int))
-> (120, if false then fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (hd 20 :: 5 :: 70 :: 3 :: 80 :: 1000 :: [] : int) (tl 20 :: 5 :: 70 :: 3 :: 80 :: 1000 :: [] : int) else fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (10) (tl 20 :: 5 :: 70 :: 3 :: 80 :: 1000 :: [] : int))
-> (120, fun (l:int list) : int -> if empty l then 10 else if hd l < 10 then fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (hd l) (tl l) else fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (10) (tl l) (tl 20 :: 5 :: 70 :: 3 :: 80 :: 1000 :: [] : int))
-> (120, fun (l:int list) : int -> if empty l then 10 else if hd l < 10 then fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (hd l) (tl l) else fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (10) (tl l) (5 :: 70 :: 3 :: 80 :: 1000 :: [] : int))
-> (120, if empty 5 :: 70 :: 3 :: 80 :: 1000 :: [] : int then 10 else if hd 5 :: 70 :: 3 :: 80 :: 1000 :: [] : int < 10 then fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (hd 5 :: 70 :: 3 :: 80 :: 1000 :: [] : int) (tl 5 :: 70 :: 3 :: 80 :: 1000 :: [] : int) else fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (10) (tl 5 :: 70 :: 3 :: 80 :: 1000 :: [] : int))
-> (120, if false then 10 else if hd 5 :: 70 :: 3 :: 80 :: 1000 :: [] : int < 10 then fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (hd 5 :: 70 :: 3 :: 80 :: 1000 :: [] : int) (tl 5 :: 70 :: 3 :: 80 :: 1000 :: [] : int) else fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (10) (tl 5 :: 70 :: 3 :: 80 :: 1000 :: [] : int))
-> (120, if 5 < 10 then fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (hd 5 :: 70 :: 3 :: 80 :: 1000 :: [] : int) (tl 5 :: 70 :: 3 :: 80 :: 1000 :: [] : int) else fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (10) (tl 5 :: 70 :: 3 :: 80 :: 1000 :: [] : int))
-> (120, if true then fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (hd 5 :: 70 :: 3 :: 80 :: 1000 :: [] : int) (tl 5 :: 70 :: 3 :: 80 :: 1000 :: [] : int) else fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (10) (tl 5 :: 70 :: 3 :: 80 :: 1000 :: [] : int))
-> (120, fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (5) (tl 5 :: 70 :: 3 :: 80 :: 1000 :: [] : int))
-> (120, fun (l:int list) : int -> if empty l then 5 else if hd l < 5 then fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (hd l) (tl l) else fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (5) (tl l) (tl 5 :: 70 :: 3 :: 80 :: 1000 :: [] : int))
-> (120, fun (l:int list) : int -> if empty l then 5 else if hd l < 5 then fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (hd l) (tl l) else fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (5) (tl l) (70 :: 3 :: 80 :: 1000 :: [] : int))
-> (120, if empty 70 :: 3 :: 80 :: 1000 :: [] : int then 5 else if hd 70 :: 3 :: 80 :: 1000 :: [] : int < 5 then fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (hd 70 :: 3 :: 80 :: 1000 :: [] : int) (tl 70 :: 3 :: 80 :: 1000 :: [] : int) else fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (5) (tl 70 :: 3 :: 80 :: 1000 :: [] : int))
-> (120, if false then 5 else if hd 70 :: 3 :: 80 :: 1000 :: [] : int < 5 then fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (hd 70 :: 3 :: 80 :: 1000 :: [] : int) (tl 70 :: 3 :: 80 :: 1000 :: [] : int) else fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (5) (tl 70 :: 3 :: 80 :: 1000 :: [] : int))
-> (120, if 70 < 5 then fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (hd 70 :: 3 :: 80 :: 1000 :: [] : int) (tl 70 :: 3 :: 80 :: 1000 :: [] : int) else fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (5) (tl 70 :: 3 :: 80 :: 1000 :: [] : int))
-> (120, if false then fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (hd 70 :: 3 :: 80 :: 1000 :: [] : int) (tl 70 :: 3 :: 80 :: 1000 :: [] : int) else fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (5) (tl 70 :: 3 :: 80 :: 1000 :: [] : int))
-> (120, fun (l:int list) : int -> if empty l then 5 else if hd l < 5 then fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (hd l) (tl l) else fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (5) (tl l) (tl 70 :: 3 :: 80 :: 1000 :: [] : int))
-> (120, fun (l:int list) : int -> if empty l then 5 else if hd l < 5 then fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (hd l) (tl l) else fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (5) (tl l) (3 :: 80 :: 1000 :: [] : int))
-> (120, if empty 3 :: 80 :: 1000 :: [] : int then 5 else if hd 3 :: 80 :: 1000 :: [] : int < 5 then fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (hd 3 :: 80 :: 1000 :: [] : int) (tl 3 :: 80 :: 1000 :: [] : int) else fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (5) (tl 3 :: 80 :: 1000 :: [] : int))
-> (120, if false then 5 else if hd 3 :: 80 :: 1000 :: [] : int < 5 then fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (hd 3 :: 80 :: 1000 :: [] : int) (tl 3 :: 80 :: 1000 :: [] : int) else fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (5) (tl 3 :: 80 :: 1000 :: [] : int))
-> (120, if 3 < 5 then fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (hd 3 :: 80 :: 1000 :: [] : int) (tl 3 :: 80 :: 1000 :: [] : int) else fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (5) (tl 3 :: 80 :: 1000 :: [] : int))
-> (120, if true then fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (hd 3 :: 80 :: 1000 :: [] : int) (tl 3 :: 80 :: 1000 :: [] : int) else fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (5) (tl 3 :: 80 :: 1000 :: [] : int))
-> (120, fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (3) (tl 3 :: 80 :: 1000 :: [] : int))
-> (120, fun (l:int list) : int -> if empty l then 3 else if hd l < 3 then fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (hd l) (tl l) else fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (3) (tl l) (tl 3 :: 80 :: 1000 :: [] : int))
-> (120, fun (l:int list) : int -> if empty l then 3 else if hd l < 3 then fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (hd l) (tl l) else fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (3) (tl l) (80 :: 1000 :: [] : int))
-> (120, if empty 80 :: 1000 :: [] : int then 3 else if hd 80 :: 1000 :: [] : int < 3 then fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (hd 80 :: 1000 :: [] : int) (tl 80 :: 1000 :: [] : int) else fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (3) (tl 80 :: 1000 :: [] : int))
-> (120, if false then 3 else if hd 80 :: 1000 :: [] : int < 3 then fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (hd 80 :: 1000 :: [] : int) (tl 80 :: 1000 :: [] : int) else fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (3) (tl 80 :: 1000 :: [] : int))
-> (120, if 80 < 3 then fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (hd 80 :: 1000 :: [] : int) (tl 80 :: 1000 :: [] : int) else fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (3) (tl 80 :: 1000 :: [] : int))
-> (120, if false then fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (hd 80 :: 1000 :: [] : int) (tl 80 :: 1000 :: [] : int) else fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (3) (tl 80 :: 1000 :: [] : int))
-> (120, fun (l:int list) : int -> if empty l then 3 else if hd l < 3 then fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (hd l) (tl l) else fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (3) (tl l) (tl 80 :: 1000 :: [] : int))
-> (120, fun (l:int list) : int -> if empty l then 3 else if hd l < 3 then fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (hd l) (tl l) else fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (3) (tl l) (1000 :: [] : int))
-> (120, if empty 1000 :: [] : int then 3 else if hd 1000 :: [] : int < 3 then fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (hd 1000 :: [] : int) (tl 1000 :: [] : int) else fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (3) (tl 1000 :: [] : int))
-> (120, if false then 3 else if hd 1000 :: [] : int < 3 then fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (hd 1000 :: [] : int) (tl 1000 :: [] : int) else fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (3) (tl 1000 :: [] : int))
-> (120, if 1000 < 3 then fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (hd 1000 :: [] : int) (tl 1000 :: [] : int) else fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (3) (tl 1000 :: [] : int))
-> (120, if false then fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (hd 1000 :: [] : int) (tl 1000 :: [] : int) else fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (3) (tl 1000 :: [] : int))
-> (120, fun (l:int list) : int -> if empty l then 3 else if hd l < 3 then fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (hd l) (tl l) else fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (3) (tl l) (tl 1000 :: [] : int))
-> (120, fun (l:int list) : int -> if empty l then 3 else if hd l < 3 then fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (hd l) (tl l) else fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (3) (tl l) ([] : int))
-> (120, if empty [] : int then 3 else if hd [] : int < 3 then fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (hd [] : int) (tl [] : int) else fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (3) (tl [] : int))
-> (120, if true then 3 else if hd [] : int < 3 then fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (hd [] : int) (tl [] : int) else fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (3) (tl [] : int))
-> (120, 3)
===== test37 =====
()
===== test38 =====
[(,)]
===== test39 =====
()
===== test40 =====
-> ()
===== test41 =====
20
===== test42 =====
[let,x,:,<,int,>,=,ref,10,in,let,y,:,<,int,>,=,ref,5,in,(,y,:=,!,x,/,!,y,),;,!,x,*,!,y]
===== test43 =====
let x : <int> = ref 10 in let y : <int> = ref 5 in y := !x / !y; !x * !y
===== test44 =====
-> let x : <int> = ref 10 in let y : <int> = ref 5 in y := !x / !y; !x * !y
-> let x : <int> = Ptr(0):{10} in let y : <int> = ref 5 in y := !x / !y; !x * !y
-> let y : <int> = ref 5 in y := !Ptr(0):{10} / !y; !Ptr(0):{10} * !y
-> let y : <int> = Ptr(1):{5} in y := !Ptr(0):{10} / !y; !Ptr(0):{10} * !y
-> Ptr(1):{5} := !Ptr(0):{10} / !Ptr(1):{5}; !Ptr(0):{10} * !Ptr(1):{5}
-> Ptr(1):{5} := 10 / !Ptr(1):{5}; !Ptr(0):{10} * !Ptr(1):{5}
-> Ptr(1):{5} := 10 / 5; !Ptr(0):{10} * !Ptr(1):{5}
-> Ptr(1):{5} := 2; !Ptr(0):{10} * !Ptr(1):{5}
-> (); !Ptr(0):{10} * !Ptr(1):{2}
-> !Ptr(0):{10} * !Ptr(1):{2}
-> 10 * !Ptr(1):{2}
-> 10 * 2
-> 20
===== test45 =====
Ptr(0):{20}
===== test46 =====
[let,x,:,<,int,>,=,ref,15,in,while,!,x,<,20,do,x,:=,!,x,+,1,end,;,x]
===== test47 =====
let x : <int> = ref 15 in while !x < 20 do x := !x + 1 end; x
===== test48 =====
-> let x : <int> = ref 15 in while !x < 20 do x := !x + 1 end; x
-> let x : <int> = Ptr(0):{15} in while !x < 20 do x := !x + 1 end; x
-> while !Ptr(0):{15} < 20 do Ptr(0):{15} := !Ptr(0):{15} + 1 end; Ptr(0):{15}
-> Ptr(0):{15} := !Ptr(0):{15} + 1; while !Ptr(0):{15} < 20 do Ptr(0):{15} := !Ptr(0):{15} + 1 end; Ptr(0):{15}
-> Ptr(0):{15} := 15 + 1; while !Ptr(0):{15} < 20 do Ptr(0):{15} := !Ptr(0):{15} + 1 end; Ptr(0):{15}
-> Ptr(0):{15} := 16; while !Ptr(0):{15} < 20 do Ptr(0):{15} := !Ptr(0):{15} + 1 end; Ptr(0):{15}
-> (); while !Ptr(0):{16} < 20 do Ptr(0):{16} := !Ptr(0):{16} + 1 end; Ptr(0):{16}
-> while !Ptr(0):{16} < 20 do Ptr(0):{16} := !Ptr(0):{16} + 1 end; Ptr(0):{16}
-> Ptr(0):{16} := !Ptr(0):{16} + 1; while !Ptr(0):{16} < 20 do Ptr(0):{16} := !Ptr(0):{16} + 1 end; Ptr(0):{16}
-> Ptr(0):{16} := 16 + 1; while !Ptr(0):{16} < 20 do Ptr(0):{16} := !Ptr(0):{16} + 1 end; Ptr(0):{16}
-> Ptr(0):{16} := 17; while !Ptr(0):{16} < 20 do Ptr(0):{16} := !Ptr(0):{16} + 1 end; Ptr(0):{16}
-> (); while !Ptr(0):{17} < 20 do Ptr(0):{17} := !Ptr(0):{17} + 1 end; Ptr(0):{17}
-> while !Ptr(0):{17} < 20 do Ptr(0):{17} := !Ptr(0):{17} + 1 end; Ptr(0):{17}
-> Ptr(0):{17} := !Ptr(0):{17} + 1; while !Ptr(0):{17} < 20 do Ptr(0):{17} := !Ptr(0):{17} + 1 end; Ptr(0):{17}
-> Ptr(0):{17} := 17 + 1; while !Ptr(0):{17} < 20 do Ptr(0):{17} := !Ptr(0):{17} + 1 end; Ptr(0):{17}
-> Ptr(0):{17} := 18; while !Ptr(0):{17} < 20 do Ptr(0):{17} := !Ptr(0):{17} + 1 end; Ptr(0):{17}
-> (); while !Ptr(0):{18} < 20 do Ptr(0):{18} := !Ptr(0):{18} + 1 end; Ptr(0):{18}
-> while !Ptr(0):{18} < 20 do Ptr(0):{18} := !Ptr(0):{18} + 1 end; Ptr(0):{18}
-> Ptr(0):{18} := !Ptr(0):{18} + 1; while !Ptr(0):{18} < 20 do Ptr(0):{18} := !Ptr(0):{18} + 1 end; Ptr(0):{18}
-> Ptr(0):{18} := 18 + 1; while !Ptr(0):{18} < 20 do Ptr(0):{18} := !Ptr(0):{18} + 1 end; Ptr(0):{18}
-> Ptr(0):{18} := 19; while !Ptr(0):{18} < 20 do Ptr(0):{18} := !Ptr(0):{18} + 1 end; Ptr(0):{18}
-> (); while !Ptr(0):{19} < 20 do Ptr(0):{19} := !Ptr(0):{19} + 1 end; Ptr(0):{19}
-> while !Ptr(0):{19} < 20 do Ptr(0):{19} := !Ptr(0):{19} + 1 end; Ptr(0):{19}
-> Ptr(0):{19} := !Ptr(0):{19} + 1; while !Ptr(0):{19} < 20 do Ptr(0):{19} := !Ptr(0):{19} + 1 end; Ptr(0):{19}
-> Ptr(0):{19} := 19 + 1; while !Ptr(0):{19} < 20 do Ptr(0):{19} := !Ptr(0):{19} + 1 end; Ptr(0):{19}
-> Ptr(0):{19} := 20; while !Ptr(0):{19} < 20 do Ptr(0):{19} := !Ptr(0):{19} + 1 end; Ptr(0):{19}
-> (); while !Ptr(0):{20} < 20 do Ptr(0):{20} := !Ptr(0):{20} + 1 end; Ptr(0):{20}
-> while !Ptr(0):{20} < 20 do Ptr(0):{20} := !Ptr(0):{20} + 1 end; Ptr(0):{20}
-> (); Ptr(0):{20}
-> Ptr(0):{20}
===== test49 =====
[Ptr(0):{40}, Ptr(1):{20}, Ptr(2):{0}, Ptr(3):{-20}]
===== test50 =====
[let,n,:,int,=,4,in,let,x,:,array,<,int,>,=,new,int,[,n,],in,let,y,:,<,int,>,=,ref,20,in,let,count,:,<,int,>,=,ref,0,in,while,!,count,<,n,do,(,x,[,!,count,],:=,!,y,+,!,y,),;,(,y,:=,!,y,-,10,),;,count,:=,!,count,+,1,end,;,x]
===== test51 =====
let n : int = 4 in let x : array<int> = new int[n] in let y : <int> = ref 20 in let count : <int> = ref 0 in while !count < n do x[!count] := !y + !y; y := !y - 10; count := !count + 1 end; x
===== test52 =====
-> let n : int = 4 in let x : array<int> = new int[n] in let y : <int> = ref 20 in let count : <int> = ref 0 in while !count < n do x[!count] := !y + !y; y := !y - 10; count := !count + 1 end; x
-> let x : array<int> = new int[4] in let y : <int> = ref 20 in let count : <int> = ref 0 in while !count < 4 do x[!count] := !y + !y; y := !y - 10; count := !count + 1 end; x
-> let x : array<int> = [Ptr(0):{()}, Ptr(1):{()}, Ptr(2):{()}, Ptr(3):{()}] in let y : <int> = ref 20 in let count : <int> = ref 0 in while !count < 4 do x[!count] := !y + !y; y := !y - 10; count := !count + 1 end; x
-> let y : <int> = ref 20 in let count : <int> = ref 0 in while !count < 4 do [Ptr(0):{()}, Ptr(1):{()}, Ptr(2):{()}, Ptr(3):{()}][!count] := !y + !y; y := !y - 10; count := !count + 1 end; [Ptr(0):{()}, Ptr(1):{()}, Ptr(2):{()}, Ptr(3):{()}]
-> let y : <int> = Ptr(4):{20} in let count : <int> = ref 0 in while !count < 4 do [Ptr(0):{()}, Ptr(1):{()}, Ptr(2):{()}, Ptr(3):{()}][!count] := !y + !y; y := !y - 10; count := !count + 1 end; [Ptr(0):{()}, Ptr(1):{()}, Ptr(2):{()}, Ptr(3):{()}]
-> let count : <int> = ref 0 in while !count < 4 do [Ptr(0):{()}, Ptr(1):{()}, Ptr(2):{()}, Ptr(3):{()}][!count] := !Ptr(4):{20} + !Ptr(4):{20}; Ptr(4):{20} := !Ptr(4):{20} - 10; count := !count + 1 end; [Ptr(0):{()}, Ptr(1):{()}, Ptr(2):{()}, Ptr(3):{()}]
-> let count : <int> = Ptr(5):{0} in while !count < 4 do [Ptr(0):{()}, Ptr(1):{()}, Ptr(2):{()}, Ptr(3):{()}][!count] := !Ptr(4):{20} + !Ptr(4):{20}; Ptr(4):{20} := !Ptr(4):{20} - 10; count := !count + 1 end; [Ptr(0):{()}, Ptr(1):{()}, Ptr(2):{()}, Ptr(3):{()}]
-> while !Ptr(5):{0} < 4 do [Ptr(0):{()}, Ptr(1):{()}, Ptr(2):{()}, Ptr(3):{()}][!Ptr(5):{0}] := !Ptr(4):{20} + !Ptr(4):{20}; Ptr(4):{20} := !Ptr(4):{20} - 10; Ptr(5):{0} := !Ptr(5):{0} + 1 end; [Ptr(0):{()}, Ptr(1):{()}, Ptr(2):{()}, Ptr(3):{()}]
-> [Ptr(0):{()}, Ptr(1):{()}, Ptr(2):{()}, Ptr(3):{()}][!Ptr(5):{0}] := !Ptr(4):{20} + !Ptr(4):{20}; Ptr(4):{20} := !Ptr(4):{20} - 10; Ptr(5):{0} := !Ptr(5):{0} + 1; while !Ptr(5):{0} < 4 do [Ptr(0):{()}, Ptr(1):{()}, Ptr(2):{()}, Ptr(3):{()}][!Ptr(5):{0}] := !Ptr(4):{20} + !Ptr(4):{20}; Ptr(4):{20} := !Ptr(4):{20} - 10; Ptr(5):{0} := !Ptr(5):{0} + 1 end; [Ptr(0):{()}, Ptr(1):{()}, Ptr(2):{()}, Ptr(3):{()}]
-> [Ptr(0):{()}, Ptr(1):{()}, Ptr(2):{()}, Ptr(3):{()}][0] := !Ptr(4):{20} + !Ptr(4):{20}; Ptr(4):{20} := !Ptr(4):{20} - 10; Ptr(5):{0} := !Ptr(5):{0} + 1; while !Ptr(5):{0} < 4 do [Ptr(0):{()}, Ptr(1):{()}, Ptr(2):{()}, Ptr(3):{()}][!Ptr(5):{0}] := !Ptr(4):{20} + !Ptr(4):{20}; Ptr(4):{20} := !Ptr(4):{20} - 10; Ptr(5):{0} := !Ptr(5):{0} + 1 end; [Ptr(0):{()}, Ptr(1):{()}, Ptr(2):{()}, Ptr(3):{()}]
-> Ptr(0):{()} := !Ptr(4):{20} + !Ptr(4):{20}; Ptr(4):{20} := !Ptr(4):{20} - 10; Ptr(5):{0} := !Ptr(5):{0} + 1; while !Ptr(5):{0} < 4 do [Ptr(0):{()}, Ptr(1):{()}, Ptr(2):{()}, Ptr(3):{()}][!Ptr(5):{0}] := !Ptr(4):{20} + !Ptr(4):{20}; Ptr(4):{20} := !Ptr(4):{20} - 10; Ptr(5):{0} := !Ptr(5):{0} + 1 end; [Ptr(0):{()}, Ptr(1):{()}, Ptr(2):{()}, Ptr(3):{()}]
-> Ptr(0):{()} := 20 + !Ptr(4):{20}; Ptr(4):{20} := !Ptr(4):{20} - 10; Ptr(5):{0} := !Ptr(5):{0} + 1; while !Ptr(5):{0} < 4 do [Ptr(0):{()}, Ptr(1):{()}, Ptr(2):{()}, Ptr(3):{()}][!Ptr(5):{0}] := !Ptr(4):{20} + !Ptr(4):{20}; Ptr(4):{20} := !Ptr(4):{20} - 10; Ptr(5):{0} := !Ptr(5):{0} + 1 end; [Ptr(0):{()}, Ptr(1):{()}, Ptr(2):{()}, Ptr(3):{()}]
-> Ptr(0):{()} := 20 + 20; Ptr(4):{20} := !Ptr(4):{20} - 10; Ptr(5):{0} := !Ptr(5):{0} + 1; while !Ptr(5):{0} < 4 do [Ptr(0):{()}, Ptr(1):{()}, Ptr(2):{()}, Ptr(3):{()}][!Ptr(5):{0}] := !Ptr(4):{20} + !Ptr(4):{20}; Ptr(4):{20} := !Ptr(4):{20} - 10; Ptr(5):{0} := !Ptr(5):{0} + 1 end; [Ptr(0):{()}, Ptr(1):{()}, Ptr(2):{()}, Ptr(3):{()}]
-> Ptr(0):{()} := 40; Ptr(4):{20} := !Ptr(4):{20} - 10; Ptr(5):{0} := !Ptr(5):{0} + 1; while !Ptr(5):{0} < 4 do [Ptr(0):{()}, Ptr(1):{()}, Ptr(2):{()}, Ptr(3):{()}][!Ptr(5):{0}] := !Ptr(4):{20} + !Ptr(4):{20}; Ptr(4):{20} := !Ptr(4):{20} - 10; Ptr(5):{0} := !Ptr(5):{0} + 1 end; [Ptr(0):{()}, Ptr(1):{()}, Ptr(2):{()}, Ptr(3):{()}]
-> (); Ptr(4):{20} := !Ptr(4):{20} - 10; Ptr(5):{0} := !Ptr(5):{0} + 1; while !Ptr(5):{0} < 4 do [Ptr(0):{40}, Ptr(1):{()}, Ptr(2):{()}, Ptr(3):{()}][!Ptr(5):{0}] := !Ptr(4):{20} + !Ptr(4):{20}; Ptr(4):{20} := !Ptr(4):{20} - 10; Ptr(5):{0} := !Ptr(5):{0} + 1 end; [Ptr(0):{40}, Ptr(1):{()}, Ptr(2):{()}, Ptr(3):{()}]
-> Ptr(4):{20} := !Ptr(4):{20} - 10; Ptr(5):{0} := !Ptr(5):{0} + 1; while !Ptr(5):{0} < 4 do [Ptr(0):{40}, Ptr(1):{()}, Ptr(2):{()}, Ptr(3):{()}][!Ptr(5):{0}] := !Ptr(4):{20} + !Ptr(4):{20}; Ptr(4):{20} := !Ptr(4):{20} - 10; Ptr(5):{0} := !Ptr(5):{0} + 1 end; [Ptr(0):{40}, Ptr(1):{()}, Ptr(2):{()}, Ptr(3):{()}]
-> Ptr(4):{20} := 20 - 10; Ptr(5):{0} := !Ptr(5):{0} + 1; while !Ptr(5):{0} < 4 do [Ptr(0):{40}, Ptr(1):{()}, Ptr(2):{()}, Ptr(3):{()}][!Ptr(5):{0}] := !Ptr(4):{20} + !Ptr(4):{20}; Ptr(4):{20} := !Ptr(4):{20} - 10; Ptr(5):{0} := !Ptr(5):{0} + 1 end; [Ptr(0):{40}, Ptr(1):{()}, Ptr(2):{()}, Ptr(3):{()}]
-> Ptr(4):{20} := 10; Ptr(5):{0} := !Ptr(5):{0} + 1; while !Ptr(5):{0} < 4 do [Ptr(0):{40}, Ptr(1):{()}, Ptr(2):{()}, Ptr(3):{()}][!Ptr(5):{0}] := !Ptr(4):{20} + !Ptr(4):{20}; Ptr(4):{20} := !Ptr(4):{20} - 10; Ptr(5):{0} := !Ptr(5):{0} + 1 end; [Ptr(0):{40}, Ptr(1):{()}, Ptr(2):{()}, Ptr(3):{()}]
-> (); Ptr(5):{0} := !Ptr(5):{0} + 1; while !Ptr(5):{0} < 4 do [Ptr(0):{40}, Ptr(1):{()}, Ptr(2):{()}, Ptr(3):{()}][!Ptr(5):{0}] := !Ptr(4):{10} + !Ptr(4):{10}; Ptr(4):{10} := !Ptr(4):{10} - 10; Ptr(5):{0} := !Ptr(5):{0} + 1 end; [Ptr(0):{40}, Ptr(1):{()}, Ptr(2):{()}, Ptr(3):{()}]
-> Ptr(5):{0} := !Ptr(5):{0} + 1; while !Ptr(5):{0} < 4 do [Ptr(0):{40}, Ptr(1):{()}, Ptr(2):{()}, Ptr(3):{()}][!Ptr(5):{0}] := !Ptr(4):{10} + !Ptr(4):{10}; Ptr(4):{10} := !Ptr(4):{10} - 10; Ptr(5):{0} := !Ptr(5):{0} + 1 end; [Ptr(0):{40}, Ptr(1):{()}, Ptr(2):{()}, Ptr(3):{()}]
-> Ptr(5):{0} := 0 + 1; while !Ptr(5):{0} < 4 do [Ptr(0):{40}, Ptr(1):{()}, Ptr(2):{()}, Ptr(3):{()}][!Ptr(5):{0}] := !Ptr(4):{10} + !Ptr(4):{10}; Ptr(4):{10} := !Ptr(4):{10} - 10; Ptr(5):{0} := !Ptr(5):{0} + 1 end; [Ptr(0):{40}, Ptr(1):{()}, Ptr(2):{()}, Ptr(3):{()}]
-> Ptr(5):{0} := 1; while !Ptr(5):{0} < 4 do [Ptr(0):{40}, Ptr(1):{()}, Ptr(2):{()}, Ptr(3):{()}][!Ptr(5):{0}] := !Ptr(4):{10} + !Ptr(4):{10}; Ptr(4):{10} := !Ptr(4):{10} - 10; Ptr(5):{0} := !Ptr(5):{0} + 1 end; [Ptr(0):{40}, Ptr(1):{()}, Ptr(2):{()}, Ptr(3):{()}]
-> (); while !Ptr(5):{1} < 4 do [Ptr(0):{40}, Ptr(1):{()}, Ptr(2):{()}, Ptr(3):{()}][!Ptr(5):{1}] := !Ptr(4):{10} + !Ptr(4):{10}; Ptr(4):{10} := !Ptr(4):{10} - 10; Ptr(5):{1} := !Ptr(5):{1} + 1 end; [Ptr(0):{40}, Ptr(1):{()}, Ptr(2):{()}, Ptr(3):{()}]
-> while !Ptr(5):{1} < 4 do [Ptr(0):{40}, Ptr(1):{()}, Ptr(2):{()}, Ptr(3):{()}][!Ptr(5):{1}] := !Ptr(4):{10} + !Ptr(4):{10}; Ptr(4):{10} := !Ptr(4):{10} - 10; Ptr(5):{1} := !Ptr(5):{1} + 1 end; [Ptr(0):{40}, Ptr(1):{()}, Ptr(2):{()}, Ptr(3):{()}]
-> [Ptr(0):{40}, Ptr(1):{()}, Ptr(2):{()}, Ptr(3):{()}][!Ptr(5):{1}] := !Ptr(4):{10} + !Ptr(4):{10}; Ptr(4):{10} := !Ptr(4):{10} - 10; Ptr(5):{1} := !Ptr(5):{1} + 1; while !Ptr(5):{1} < 4 do [Ptr(0):{40}, Ptr(1):{()}, Ptr(2):{()}, Ptr(3):{()}][!Ptr(5):{1}] := !Ptr(4):{10} + !Ptr(4):{10}; Ptr(4):{10} := !Ptr(4):{10} - 10; Ptr(5):{1} := !Ptr(5):{1} + 1 end; [Ptr(0):{40}, Ptr(1):{()}, Ptr(2):{()}, Ptr(3):{()}]
-> [Ptr(0):{40}, Ptr(1):{()}, Ptr(2):{()}, Ptr(3):{()}][1] := !Ptr(4):{10} + !Ptr(4):{10}; Ptr(4):{10} := !Ptr(4):{10} - 10; Ptr(5):{1} := !Ptr(5):{1} + 1; while !Ptr(5):{1} < 4 do [Ptr(0):{40}, Ptr(1):{()}, Ptr(2):{()}, Ptr(3):{()}][!Ptr(5):{1}] := !Ptr(4):{10} + !Ptr(4):{10}; Ptr(4):{10} := !Ptr(4):{10} - 10; Ptr(5):{1} := !Ptr(5):{1} + 1 end; [Ptr(0):{40}, Ptr(1):{()}, Ptr(2):{()}, Ptr(3):{()}]
-> Ptr(1):{()} := !Ptr(4):{10} + !Ptr(4):{10}; Ptr(4):{10} := !Ptr(4):{10} - 10; Ptr(5):{1} := !Ptr(5):{1} + 1; while !Ptr(5):{1} < 4 do [Ptr(0):{40}, Ptr(1):{()}, Ptr(2):{()}, Ptr(3):{()}][!Ptr(5):{1}] := !Ptr(4):{10} + !Ptr(4):{10}; Ptr(4):{10} := !Ptr(4):{10} - 10; Ptr(5):{1} := !Ptr(5):{1} + 1 end; [Ptr(0):{40}, Ptr(1):{()}, Ptr(2):{()}, Ptr(3):{()}]
-> Ptr(1):{()} := 10 + !Ptr(4):{10}; Ptr(4):{10} := !Ptr(4):{10} - 10; Ptr(5):{1} := !Ptr(5):{1} + 1; while !Ptr(5):{1} < 4 do [Ptr(0):{40}, Ptr(1):{()}, Ptr(2):{()}, Ptr(3):{()}][!Ptr(5):{1}] := !Ptr(4):{10} + !Ptr(4):{10}; Ptr(4):{10} := !Ptr(4):{10} - 10; Ptr(5):{1} := !Ptr(5):{1} + 1 end; [Ptr(0):{40}, Ptr(1):{()}, Ptr(2):{()}, Ptr(3):{()}]
-> Ptr(1):{()} := 10 + 10; Ptr(4):{10} := !Ptr(4):{10} - 10; Ptr(5):{1} := !Ptr(5):{1} + 1; while !Ptr(5):{1} < 4 do [Ptr(0):{40}, Ptr(1):{()}, Ptr(2):{()}, Ptr(3):{()}][!Ptr(5):{1}] := !Ptr(4):{10} + !Ptr(4):{10}; Ptr(4):{10} := !Ptr(4):{10} - 10; Ptr(5):{1} := !Ptr(5):{1} + 1 end; [Ptr(0):{40}, Ptr(1):{()}, Ptr(2):{()}, Ptr(3):{()}]
-> Ptr(1):{()} := 20; Ptr(4):{10} := !Ptr(4):{10} - 10; Ptr(5):{1} := !Ptr(5):{1} + 1; while !Ptr(5):{1} < 4 do [Ptr(0):{40}, Ptr(1):{()}, Ptr(2):{()}, Ptr(3):{()}][!Ptr(5):{1}] := !Ptr(4):{10} + !Ptr(4):{10}; Ptr(4):{10} := !Ptr(4):{10} - 10; Ptr(5):{1} := !Ptr(5):{1} + 1 end; [Ptr(0):{40}, Ptr(1):{()}, Ptr(2):{()}, Ptr(3):{()}]
-> (); Ptr(4):{10} := !Ptr(4):{10} - 10; Ptr(5):{1} := !Ptr(5):{1} + 1; while !Ptr(5):{1} < 4 do [Ptr(0):{40}, Ptr(1):{20}, Ptr(2):{()}, Ptr(3):{()}][!Ptr(5):{1}] := !Ptr(4):{10} + !Ptr(4):{10}; Ptr(4):{10} := !Ptr(4):{10} - 10; Ptr(5):{1} := !Ptr(5):{1} + 1 end; [Ptr(0):{40}, Ptr(1):{20}, Ptr(2):{()}, Ptr(3):{()}]
-> Ptr(4):{10} := !Ptr(4):{10} - 10; Ptr(5):{1} := !Ptr(5):{1} + 1; while !Ptr(5):{1} < 4 do [Ptr(0):{40}, Ptr(1):{20}, Ptr(2):{()}, Ptr(3):{()}][!Ptr(5):{1}] := !Ptr(4):{10} + !Ptr(4):{10}; Ptr(4):{10} := !Ptr(4):{10} - 10; Ptr(5):{1} := !Ptr(5):{1} + 1 end; [Ptr(0):{40}, Ptr(1):{20}, Ptr(2):{()}, Ptr(3):{()}]
-> Ptr(4):{10} := 10 - 10; Ptr(5):{1} := !Ptr(5):{1} + 1; while !Ptr(5):{1} < 4 do [Ptr(0):{40}, Ptr(1):{20}, Ptr(2):{()}, Ptr(3):{()}][!Ptr(5):{1}] := !Ptr(4):{10} + !Ptr(4):{10}; Ptr(4):{10} := !Ptr(4):{10} - 10; Ptr(5):{1} := !Ptr(5):{1} + 1 end; [Ptr(0):{40}, Ptr(1):{20}, Ptr(2):{()}, Ptr(3):{()}]
-> Ptr(4):{10} := 0; Ptr(5):{1} := !Ptr(5):{1} + 1; while !Ptr(5):{1} < 4 do [Ptr(0):{40}, Ptr(1):{20}, Ptr(2):{()}, Ptr(3):{()}][!Ptr(5):{1}] := !Ptr(4):{10} + !Ptr(4):{10}; Ptr(4):{10} := !Ptr(4):{10} - 10; Ptr(5):{1} := !Ptr(5):{1} + 1 end; [Ptr(0):{40}, Ptr(1):{20}, Ptr(2):{()}, Ptr(3):{()}]
-> (); Ptr(5):{1} := !Ptr(5):{1} + 1; while !Ptr(5):{1} < 4 do [Ptr(0):{40}, Ptr(1):{20}, Ptr(2):{()}, Ptr(3):{()}][!Ptr(5):{1}] := !Ptr(4):{0} + !Ptr(4):{0}; Ptr(4):{0} := !Ptr(4):{0} - 10; Ptr(5):{1} := !Ptr(5):{1} + 1 end; [Ptr(0):{40}, Ptr(1):{20}, Ptr(2):{()}, Ptr(3):{()}]
-> Ptr(5):{1} := !Ptr(5):{1} + 1; while !Ptr(5):{1} < 4 do [Ptr(0):{40}, Ptr(1):{20}, Ptr(2):{()}, Ptr(3):{()}][!Ptr(5):{1}] := !Ptr(4):{0} + !Ptr(4):{0}; Ptr(4):{0} := !Ptr(4):{0} - 10; Ptr(5):{1} := !Ptr(5):{1} + 1 end; [Ptr(0):{40}, Ptr(1):{20}, Ptr(2):{()}, Ptr(3):{()}]
-> Ptr(5):{1} := 1 + 1; while !Ptr(5):{1} < 4 do [Ptr(0):{40}, Ptr(1):{20}, Ptr(2):{()}, Ptr(3):{()}][!Ptr(5):{1}] := !Ptr(4):{0} + !Ptr(4):{0}; Ptr(4):{0} := !Ptr(4):{0} - 10; Ptr(5):{1} := !Ptr(5):{1} + 1 end; [Ptr(0):{40}, Ptr(1):{20}, Ptr(2):{()}, Ptr(3):{()}]
-> Ptr(5):{1} := 2; while !Ptr(5):{1} < 4 do [Ptr(0):{40}, Ptr(1):{20}, Ptr(2):{()}, Ptr(3):{()}][!Ptr(5):{1}] := !Ptr(4):{0} + !Ptr(4):{0}; Ptr(4):{0} := !Ptr(4):{0} - 10; Ptr(5):{1} := !Ptr(5):{1} + 1 end; [Ptr(0):{40}, Ptr(1):{20}, Ptr(2):{()}, Ptr(3):{()}]
-> (); while !Ptr(5):{2} < 4 do [Ptr(0):{40}, Ptr(1):{20}, Ptr(2):{()}, Ptr(3):{()}][!Ptr(5):{2}] := !Ptr(4):{0} + !Ptr(4):{0}; Ptr(4):{0} := !Ptr(4):{0} - 10; Ptr(5):{2} := !Ptr(5):{2} + 1 end; [Ptr(0):{40}, Ptr(1):{20}, Ptr(2):{()}, Ptr(3):{()}]
-> while !Ptr(5):{2} < 4 do [Ptr(0):{40}, Ptr(1):{20}, Ptr(2):{()}, Ptr(3):{()}][!Ptr(5):{2}] := !Ptr(4):{0} + !Ptr(4):{0}; Ptr(4):{0} := !Ptr(4):{0} - 10; Ptr(5):{2} := !Ptr(5):{2} + 1 end; [Ptr(0):{40}, Ptr(1):{20}, Ptr(2):{()}, Ptr(3):{()}]
-> [Ptr(0):{40}, Ptr(1):{20}, Ptr(2):{()}, Ptr(3):{()}][!Ptr(5):{2}] := !Ptr(4):{0} + !Ptr(4):{0}; Ptr(4):{0} := !Ptr(4):{0} - 10; Ptr(5):{2} := !Ptr(5):{2} + 1; while !Ptr(5):{2} < 4 do [Ptr(0):{40}, Ptr(1):{20}, Ptr(2):{()}, Ptr(3):{()}][!Ptr(5):{2}] := !Ptr(4):{0} + !Ptr(4):{0}; Ptr(4):{0} := !Ptr(4):{0} - 10; Ptr(5):{2} := !Ptr(5):{2} + 1 end; [Ptr(0):{40}, Ptr(1):{20}, Ptr(2):{()}, Ptr(3):{()}]
-> [Ptr(0):{40}, Ptr(1):{20}, Ptr(2):{()}, Ptr(3):{()}][2] := !Ptr(4):{0} + !Ptr(4):{0}; Ptr(4):{0} := !Ptr(4):{0} - 10; Ptr(5):{2} := !Ptr(5):{2} + 1; while !Ptr(5):{2} < 4 do [Ptr(0):{40}, Ptr(1):{20}, Ptr(2):{()}, Ptr(3):{()}][!Ptr(5):{2}] := !Ptr(4):{0} + !Ptr(4):{0}; Ptr(4):{0} := !Ptr(4):{0} - 10; Ptr(5):{2} := !Ptr(5):{2} + 1 end; [Ptr(0):{40}, Ptr(1):{20}, Ptr(2):{()}, Ptr(3):{()}]
-> Ptr(2):{()} := !Ptr(4):{0} + !Ptr(4):{0}; Ptr(4):{0} := !Ptr(4):{0} - 10; Ptr(5):{2} := !Ptr(5):{2} + 1; while !Ptr(5):{2} < 4 do [Ptr(0):{40}, Ptr(1):{20}, Ptr(2):{()}, Ptr(3):{()}][!Ptr(5):{2}] := !Ptr(4):{0} + !Ptr(4):{0}; Ptr(4):{0} := !Ptr(4):{0} - 10; Ptr(5):{2} := !Ptr(5):{2} + 1 end; [Ptr(0):{40}, Ptr(1):{20}, Ptr(2):{()}, Ptr(3):{()}]
-> Ptr(2):{()} := 0 + !Ptr(4):{0}; Ptr(4):{0} := !Ptr(4):{0} - 10; Ptr(5):{2} := !Ptr(5):{2} + 1; while !Ptr(5):{2} < 4 do [Ptr(0):{40}, Ptr(1):{20}, Ptr(2):{()}, Ptr(3):{()}][!Ptr(5):{2}] := !Ptr(4):{0} + !Ptr(4):{0}; Ptr(4):{0} := !Ptr(4):{0} - 10; Ptr(5):{2} := !Ptr(5):{2} + 1 end; [Ptr(0):{40}, Ptr(1):{20}, Ptr(2):{()}, Ptr(3):{()}]
-> Ptr(2):{()} := 0 + 0; Ptr(4):{0} := !Ptr(4):{0} - 10; Ptr(5):{2} := !Ptr(5):{2} + 1; while !Ptr(5):{2} < 4 do [Ptr(0):{40}, Ptr(1):{20}, Ptr(2):{()}, Ptr(3):{()}][!Ptr(5):{2}] := !Ptr(4):{0} + !Ptr(4):{0}; Ptr(4):{0} := !Ptr(4):{0} - 10; Ptr(5):{2} := !Ptr(5):{2} + 1 end; [Ptr(0):{40}, Ptr(1):{20}, Ptr(2):{()}, Ptr(3):{()}]
-> Ptr(2):{()} := 0; Ptr(4):{0} := !Ptr(4):{0} - 10; Ptr(5):{2} := !Ptr(5):{2} + 1; while !Ptr(5):{2} < 4 do [Ptr(0):{40}, Ptr(1):{20}, Ptr(2):{()}, Ptr(3):{()}][!Ptr(5):{2}] := !Ptr(4):{0} + !Ptr(4):{0}; Ptr(4):{0} := !Ptr(4):{0} - 10; Ptr(5):{2} := !Ptr(5):{2} + 1 end; [Ptr(0):{40}, Ptr(1):{20}, Ptr(2):{()}, Ptr(3):{()}]
-> (); Ptr(4):{0} := !Ptr(4):{0} - 10; Ptr(5):{2} := !Ptr(5):{2} + 1; while !Ptr(5):{2} < 4 do [Ptr(0):{40}, Ptr(1):{20}, Ptr(2):{0}, Ptr(3):{()}][!Ptr(5):{2}] := !Ptr(4):{0} + !Ptr(4):{0}; Ptr(4):{0} := !Ptr(4):{0} - 10; Ptr(5):{2} := !Ptr(5):{2} + 1 end; [Ptr(0):{40}, Ptr(1):{20}, Ptr(2):{0}, Ptr(3):{()}]
-> Ptr(4):{0} := !Ptr(4):{0} - 10; Ptr(5):{2} := !Ptr(5):{2} + 1; while !Ptr(5):{2} < 4 do [Ptr(0):{40}, Ptr(1):{20}, Ptr(2):{0}, Ptr(3):{()}][!Ptr(5):{2}] := !Ptr(4):{0} + !Ptr(4):{0}; Ptr(4):{0} := !Ptr(4):{0} - 10; Ptr(5):{2} := !Ptr(5):{2} + 1 end; [Ptr(0):{40}, Ptr(1):{20}, Ptr(2):{0}, Ptr(3):{()}]
-> Ptr(4):{0} := 0 - 10; Ptr(5):{2} := !Ptr(5):{2} + 1; while !Ptr(5):{2} < 4 do [Ptr(0):{40}, Ptr(1):{20}, Ptr(2):{0}, Ptr(3):{()}][!Ptr(5):{2}] := !Ptr(4):{0} + !Ptr(4):{0}; Ptr(4):{0} := !Ptr(4):{0} - 10; Ptr(5):{2} := !Ptr(5):{2} + 1 end; [Ptr(0):{40}, Ptr(1):{20}, Ptr(2):{0}, Ptr(3):{()}]
-> Ptr(4):{0} := -10; Ptr(5):{2} := !Ptr(5):{2} + 1; while !Ptr(5):{2} < 4 do [Ptr(0):{40}, Ptr(1):{20}, Ptr(2):{0}, Ptr(3):{()}][!Ptr(5):{2}] := !Ptr(4):{0} + !Ptr(4):{0}; Ptr(4):{0} := !Ptr(4):{0} - 10; Ptr(5):{2} := !Ptr(5):{2} + 1 end; [Ptr(0):{40}, Ptr(1):{20}, Ptr(2):{0}, Ptr(3):{()}]
-> (); Ptr(5):{2} := !Ptr(5):{2} + 1; while !Ptr(5):{2} < 4 do [Ptr(0):{40}, Ptr(1):{20}, Ptr(2):{0}, Ptr(3):{()}][!Ptr(5):{2}] := !Ptr(4):{-10} + !Ptr(4):{-10}; Ptr(4):{-10} := !Ptr(4):{-10} - 10; Ptr(5):{2} := !Ptr(5):{2} + 1 end; [Ptr(0):{40}, Ptr(1):{20}, Ptr(2):{0}, Ptr(3):{()}]
-> Ptr(5):{2} := !Ptr(5):{2} + 1; while !Ptr(5):{2} < 4 do [Ptr(0):{40}, Ptr(1):{20}, Ptr(2):{0}, Ptr(3):{()}][!Ptr(5):{2}] := !Ptr(4):{-10} + !Ptr(4):{-10}; Ptr(4):{-10} := !Ptr(4):{-10} - 10; Ptr(5):{2} := !Ptr(5):{2} + 1 end; [Ptr(0):{40}, Ptr(1):{20}, Ptr(2):{0}, Ptr(3):{()}]
-> Ptr(5):{2} := 2 + 1; while !Ptr(5):{2} < 4 do [Ptr(0):{40}, Ptr(1):{20}, Ptr(2):{0}, Ptr(3):{()}][!Ptr(5):{2}] := !Ptr(4):{-10} + !Ptr(4):{-10}; Ptr(4):{-10} := !Ptr(4):{-10} - 10; Ptr(5):{2} := !Ptr(5):{2} + 1 end; [Ptr(0):{40}, Ptr(1):{20}, Ptr(2):{0}, Ptr(3):{()}]
-> Ptr(5):{2} := 3; while !Ptr(5):{2} < 4 do [Ptr(0):{40}, Ptr(1):{20}, Ptr(2):{0}, Ptr(3):{()}][!Ptr(5):{2}] := !Ptr(4):{-10} + !Ptr(4):{-10}; Ptr(4):{-10} := !Ptr(4):{-10} - 10; Ptr(5):{2} := !Ptr(5):{2} + 1 end; [Ptr(0):{40}, Ptr(1):{20}, Ptr(2):{0}, Ptr(3):{()}]
-> (); while !Ptr(5):{3} < 4 do [Ptr(0):{40}, Ptr(1):{20}, Ptr(2):{0}, Ptr(3):{()}][!Ptr(5):{3}] := !Ptr(4):{-10} + !Ptr(4):{-10}; Ptr(4):{-10} := !Ptr(4):{-10} - 10; Ptr(5):{3} := !Ptr(5):{3} + 1 end; [Ptr(0):{40}, Ptr(1):{20}, Ptr(2):{0}, Ptr(3):{()}]
-> while !Ptr(5):{3} < 4 do [Ptr(0):{40}, Ptr(1):{20}, Ptr(2):{0}, Ptr(3):{()}][!Ptr(5):{3}] := !Ptr(4):{-10} + !Ptr(4):{-10}; Ptr(4):{-10} := !Ptr(4):{-10} - 10; Ptr(5):{3} := !Ptr(5):{3} + 1 end; [Ptr(0):{40}, Ptr(1):{20}, Ptr(2):{0}, Ptr(3):{()}]
-> [Ptr(0):{40}, Ptr(1):{20}, Ptr(2):{0}, Ptr(3):{()}][!Ptr(5):{3}] := !Ptr(4):{-10} + !Ptr(4):{-10}; Ptr(4):{-10} := !Ptr(4):{-10} - 10; Ptr(5):{3} := !Ptr(5):{3} + 1; while !Ptr(5):{3} < 4 do [Ptr(0):{40}, Ptr(1):{20}, Ptr(2):{0}, Ptr(3):{()}][!Ptr(5):{3}] := !Ptr(4):{-10} + !Ptr(4):{-10}; Ptr(4):{-10} := !Ptr(4):{-10} - 10; Ptr(5):{3} := !Ptr(5):{3} + 1 end; [Ptr(0):{40}, Ptr(1):{20}, Ptr(2):{0}, Ptr(3):{()}]
-> [Ptr(0):{40}, Ptr(1):{20}, Ptr(2):{0}, Ptr(3):{()}][3] := !Ptr(4):{-10} + !Ptr(4):{-10}; Ptr(4):{-10} := !Ptr(4):{-10} - 10; Ptr(5):{3} := !Ptr(5):{3} + 1; while !Ptr(5):{3} < 4 do [Ptr(0):{40}, Ptr(1):{20}, Ptr(2):{0}, Ptr(3):{()}][!Ptr(5):{3}] := !Ptr(4):{-10} + !Ptr(4):{-10}; Ptr(4):{-10} := !Ptr(4):{-10} - 10; Ptr(5):{3} := !Ptr(5):{3} + 1 end; [Ptr(0):{40}, Ptr(1):{20}, Ptr(2):{0}, Ptr(3):{()}]
-> Ptr(3):{()} := !Ptr(4):{-10} + !Ptr(4):{-10}; Ptr(4):{-10} := !Ptr(4):{-10} - 10; Ptr(5):{3} := !Ptr(5):{3} + 1; while !Ptr(5):{3} < 4 do [Ptr(0):{40}, Ptr(1):{20}, Ptr(2):{0}, Ptr(3):{()}][!Ptr(5):{3}] := !Ptr(4):{-10} + !Ptr(4):{-10}; Ptr(4):{-10} := !Ptr(4):{-10} - 10; Ptr(5):{3} := !Ptr(5):{3} + 1 end; [Ptr(0):{40}, Ptr(1):{20}, Ptr(2):{0}, Ptr(3):{()}]
-> Ptr(3):{()} := -10 + !Ptr(4):{-10}; Ptr(4):{-10} := !Ptr(4):{-10} - 10; Ptr(5):{3} := !Ptr(5):{3} + 1; while !Ptr(5):{3} < 4 do [Ptr(0):{40}, Ptr(1):{20}, Ptr(2):{0}, Ptr(3):{()}][!Ptr(5):{3}] := !Ptr(4):{-10} + !Ptr(4):{-10}; Ptr(4):{-10} := !Ptr(4):{-10} - 10; Ptr(5):{3} := !Ptr(5):{3} + 1 end; [Ptr(0):{40}, Ptr(1):{20}, Ptr(2):{0}, Ptr(3):{()}]
-> Ptr(3):{()} := -10 + -10; Ptr(4):{-10} := !Ptr(4):{-10} - 10; Ptr(5):{3} := !Ptr(5):{3} + 1; while !Ptr(5):{3} < 4 do [Ptr(0):{40}, Ptr(1):{20}, Ptr(2):{0}, Ptr(3):{()}][!Ptr(5):{3}] := !Ptr(4):{-10} + !Ptr(4):{-10}; Ptr(4):{-10} := !Ptr(4):{-10} - 10; Ptr(5):{3} := !Ptr(5):{3} + 1 end; [Ptr(0):{40}, Ptr(1):{20}, Ptr(2):{0}, Ptr(3):{()}]
-> Ptr(3):{()} := -20; Ptr(4):{-10} := !Ptr(4):{-10} - 10; Ptr(5):{3} := !Ptr(5):{3} + 1; while !Ptr(5):{3} < 4 do [Ptr(0):{40}, Ptr(1):{20}, Ptr(2):{0}, Ptr(3):{()}][!Ptr(5):{3}] := !Ptr(4):{-10} + !Ptr(4):{-10}; Ptr(4):{-10} := !Ptr(4):{-10} - 10; Ptr(5):{3} := !Ptr(5):{3} + 1 end; [Ptr(0):{40}, Ptr(1):{20}, Ptr(2):{0}, Ptr(3):{()}]
-> (); Ptr(4):{-10} := !Ptr(4):{-10} - 10; Ptr(5):{3} := !Ptr(5):{3} + 1; while !Ptr(5):{3} < 4 do [Ptr(0):{40}, Ptr(1):{20}, Ptr(2):{0}, Ptr(3):{-20}][!Ptr(5):{3}] := !Ptr(4):{-10} + !Ptr(4):{-10}; Ptr(4):{-10} := !Ptr(4):{-10} - 10; Ptr(5):{3} := !Ptr(5):{3} + 1 end; [Ptr(0):{40}, Ptr(1):{20}, Ptr(2):{0}, Ptr(3):{-20}]
-> Ptr(4):{-10} := !Ptr(4):{-10} - 10; Ptr(5):{3} := !Ptr(5):{3} + 1; while !Ptr(5):{3} < 4 do [Ptr(0):{40}, Ptr(1):{20}, Ptr(2):{0}, Ptr(3):{-20}][!Ptr(5):{3}] := !Ptr(4):{-10} + !Ptr(4):{-10}; Ptr(4):{-10} := !Ptr(4):{-10} - 10; Ptr(5):{3} := !Ptr(5):{3} + 1 end; [Ptr(0):{40}, Ptr(1):{20}, Ptr(2):{0}, Ptr(3):{-20}]
-> Ptr(4):{-10} := -10 - 10; Ptr(5):{3} := !Ptr(5):{3} + 1; while !Ptr(5):{3} < 4 do [Ptr(0):{40}, Ptr(1):{20}, Ptr(2):{0}, Ptr(3):{-20}][!Ptr(5):{3}] := !Ptr(4):{-10} + !Ptr(4):{-10}; Ptr(4):{-10} := !Ptr(4):{-10} - 10; Ptr(5):{3} := !Ptr(5):{3} + 1 end; [Ptr(0):{40}, Ptr(1):{20}, Ptr(2):{0}, Ptr(3):{-20}]
-> Ptr(4):{-10} := -20; Ptr(5):{3} := !Ptr(5):{3} + 1; while !Ptr(5):{3} < 4 do [Ptr(0):{40}, Ptr(1):{20}, Ptr(2):{0}, Ptr(3):{-20}][!Ptr(5):{3}] := !Ptr(4):{-10} + !Ptr(4):{-10}; Ptr(4):{-10} := !Ptr(4):{-10} - 10; Ptr(5):{3} := !Ptr(5):{3} + 1 end; [Ptr(0):{40}, Ptr(1):{20}, Ptr(2):{0}, Ptr(3):{-20}]
-> (); Ptr(5):{3} := !Ptr(5):{3} + 1; while !Ptr(5):{3} < 4 do [Ptr(0):{40}, Ptr(1):{20}, Ptr(2):{0}, Ptr(3):{-20}][!Ptr(5):{3}] := !Ptr(4):{-20} + !Ptr(4):{-20}; Ptr(4):{-20} := !Ptr(4):{-20} - 10; Ptr(5):{3} := !Ptr(5):{3} + 1 end; [Ptr(0):{40}, Ptr(1):{20}, Ptr(2):{0}, Ptr(3):{-20}]
-> Ptr(5):{3} := !Ptr(5):{3} + 1; while !Ptr(5):{3} < 4 do [Ptr(0):{40}, Ptr(1):{20}, Ptr(2):{0}, Ptr(3):{-20}][!Ptr(5):{3}] := !Ptr(4):{-20} + !Ptr(4):{-20}; Ptr(4):{-20} := !Ptr(4):{-20} - 10; Ptr(5):{3} := !Ptr(5):{3} + 1 end; [Ptr(0):{40}, Ptr(1):{20}, Ptr(2):{0}, Ptr(3):{-20}]
-> Ptr(5):{3} := 3 + 1; while !Ptr(5):{3} < 4 do [Ptr(0):{40}, Ptr(1):{20}, Ptr(2):{0}, Ptr(3):{-20}][!Ptr(5):{3}] := !Ptr(4):{-20} + !Ptr(4):{-20}; Ptr(4):{-20} := !Ptr(4):{-20} - 10; Ptr(5):{3} := !Ptr(5):{3} + 1 end; [Ptr(0):{40}, Ptr(1):{20}, Ptr(2):{0}, Ptr(3):{-20}]
-> Ptr(5):{3} := 4; while !Ptr(5):{3} < 4 do [Ptr(0):{40}, Ptr(1):{20}, Ptr(2):{0}, Ptr(3):{-20}][!Ptr(5):{3}] := !Ptr(4):{-20} + !Ptr(4):{-20}; Ptr(4):{-20} := !Ptr(4):{-20} - 10; Ptr(5):{3} := !Ptr(5):{3} + 1 end; [Ptr(0):{40}, Ptr(1):{20}, Ptr(2):{0}, Ptr(3):{-20}]
-> (); while !Ptr(5):{4} < 4 do [Ptr(0):{40}, Ptr(1):{20}, Ptr(2):{0}, Ptr(3):{-20}][!Ptr(5):{4}] := !Ptr(4):{-20} + !Ptr(4):{-20}; Ptr(4):{-20} := !Ptr(4):{-20} - 10; Ptr(5):{4} := !Ptr(5):{4} + 1 end; [Ptr(0):{40}, Ptr(1):{20}, Ptr(2):{0}, Ptr(3):{-20}]
-> while !Ptr(5):{4} < 4 do [Ptr(0):{40}, Ptr(1):{20}, Ptr(2):{0}, Ptr(3):{-20}][!Ptr(5):{4}] := !Ptr(4):{-20} + !Ptr(4):{-20}; Ptr(4):{-20} := !Ptr(4):{-20} - 10; Ptr(5):{4} := !Ptr(5):{4} + 1 end; [Ptr(0):{40}, Ptr(1):{20}, Ptr(2):{0}, Ptr(3):{-20}]
-> (); [Ptr(0):{40}, Ptr(1):{20}, Ptr(2):{0}, Ptr(3):{-20}]
-> [Ptr(0):{40}, Ptr(1):{20}, Ptr(2):{0}, Ptr(3):{-20}]
===== test53 =====
[Ptr(0):{(true, 1)}, Ptr(1):{(true, 2)}, Ptr(2):{(true, 3)}, Ptr(3):{(true, 4)}]
===== test54 =====
[let,n,:,int,=,4,in,let,x,:,array,<,bool,*,int,>,=,new,(,bool,*,int,),[,n,],in,let,y,:,<,int,>,=,ref,1,in,let,count,:,<,int,>,=,ref,0,in,while,!,count,<,n,do,(,x,[,!,count,],:=,(,true,,,!,y,),),;,(,y,:=,!,y,+,1,),;,count,:=,!,count,+,1,end,;,x]
===== test55 =====
let n : int = 4 in let x : array<(bool * int)> = new (bool * int)[n] in let y : <int> = ref 1 in let count : <int> = ref 0 in while !count < n do x[!count] := (true, !y); y := !y + 1; count := !count + 1 end; x
===== test56 =====
-> let n : int = 4 in let x : array<(bool * int)> = new (bool * int)[n] in let y : <int> = ref 1 in let count : <int> = ref 0 in while !count < n do x[!count] := (true, !y); y := !y + 1; count := !count + 1 end; x
-> let x : array<(bool * int)> = new (bool * int)[4] in let y : <int> = ref 1 in let count : <int> = ref 0 in while !count < 4 do x[!count] := (true, !y); y := !y + 1; count := !count + 1 end; x
-> let x : array<(bool * int)> = [Ptr(0):{()}, Ptr(1):{()}, Ptr(2):{()}, Ptr(3):{()}] in let y : <int> = ref 1 in let count : <int> = ref 0 in while !count < 4 do x[!count] := (true, !y); y := !y + 1; count := !count + 1 end; x
-> let y : <int> = ref 1 in let count : <int> = ref 0 in while !count < 4 do [Ptr(0):{()}, Ptr(1):{()}, Ptr(2):{()}, Ptr(3):{()}][!count] := (true, !y); y := !y + 1; count := !count + 1 end; [Ptr(0):{()}, Ptr(1):{()}, Ptr(2):{()}, Ptr(3):{()}]
-> let y : <int> = Ptr(4):{1} in let count : <int> = ref 0 in while !count < 4 do [Ptr(0):{()}, Ptr(1):{()}, Ptr(2):{()}, Ptr(3):{()}][!count] := (true, !y); y := !y + 1; count := !count + 1 end; [Ptr(0):{()}, Ptr(1):{()}, Ptr(2):{()}, Ptr(3):{()}]
-> let count : <int> = ref 0 in while !count < 4 do [Ptr(0):{()}, Ptr(1):{()}, Ptr(2):{()}, Ptr(3):{()}][!count] := (true, !Ptr(4):{1}); Ptr(4):{1} := !Ptr(4):{1} + 1; count := !count + 1 end; [Ptr(0):{()}, Ptr(1):{()}, Ptr(2):{()}, Ptr(3):{()}]
-> let count : <int> = Ptr(5):{0} in while !count < 4 do [Ptr(0):{()}, Ptr(1):{()}, Ptr(2):{()}, Ptr(3):{()}][!count] := (true, !Ptr(4):{1}); Ptr(4):{1} := !Ptr(4):{1} + 1; count := !count + 1 end; [Ptr(0):{()}, Ptr(1):{()}, Ptr(2):{()}, Ptr(3):{()}]
-> while !Ptr(5):{0} < 4 do [Ptr(0):{()}, Ptr(1):{()}, Ptr(2):{()}, Ptr(3):{()}][!Ptr(5):{0}] := (true, !Ptr(4):{1}); Ptr(4):{1} := !Ptr(4):{1} + 1; Ptr(5):{0} := !Ptr(5):{0} + 1 end; [Ptr(0):{()}, Ptr(1):{()}, Ptr(2):{()}, Ptr(3):{()}]
-> [Ptr(0):{()}, Ptr(1):{()}, Ptr(2):{()}, Ptr(3):{()}][!Ptr(5):{0}] := (true, !Ptr(4):{1}); Ptr(4):{1} := !Ptr(4):{1} + 1; Ptr(5):{0} := !Ptr(5):{0} + 1; while !Ptr(5):{0} < 4 do [Ptr(0):{()}, Ptr(1):{()}, Ptr(2):{()}, Ptr(3):{()}][!Ptr(5):{0}] := (true, !Ptr(4):{1}); Ptr(4):{1} := !Ptr(4):{1} + 1; Ptr(5):{0} := !Ptr(5):{0} + 1 end; [Ptr(0):{()}, Ptr(1):{()}, Ptr(2):{()}, Ptr(3):{()}]
-> [Ptr(0):{()}, Ptr(1):{()}, Ptr(2):{()}, Ptr(3):{()}][0] := (true, !Ptr(4):{1}); Ptr(4):{1} := !Ptr(4):{1} + 1; Ptr(5):{0} := !Ptr(5):{0} + 1; while !Ptr(5):{0} < 4 do [Ptr(0):{()}, Ptr(1):{()}, Ptr(2):{()}, Ptr(3):{()}][!Ptr(5):{0}] := (true, !Ptr(4):{1}); Ptr(4):{1} := !Ptr(4):{1} + 1; Ptr(5):{0} := !Ptr(5):{0} + 1 end; [Ptr(0):{()}, Ptr(1):{()}, Ptr(2):{()}, Ptr(3):{()}]
-> Ptr(0):{()} := (true, !Ptr(4):{1}); Ptr(4):{1} := !Ptr(4):{1} + 1; Ptr(5):{0} := !Ptr(5):{0} + 1; while !Ptr(5):{0} < 4 do [Ptr(0):{()}, Ptr(1):{()}, Ptr(2):{()}, Ptr(3):{()}][!Ptr(5):{0}] := (true, !Ptr(4):{1}); Ptr(4):{1} := !Ptr(4):{1} + 1; Ptr(5):{0} := !Ptr(5):{0} + 1 end; [Ptr(0):{()}, Ptr(1):{()}, Ptr(2):{()}, Ptr(3):{()}]
-> Ptr(0):{()} := (true, 1); Ptr(4):{1} := !Ptr(4):{1} + 1; Ptr(5):{0} := !Ptr(5):{0} + 1; while !Ptr(5):{0} < 4 do [Ptr(0):{()}, Ptr(1):{()}, Ptr(2):{()}, Ptr(3):{()}][!Ptr(5):{0}] := (true, !Ptr(4):{1}); Ptr(4):{1} := !Ptr(4):{1} + 1; Ptr(5):{0} := !Ptr(5):{0} + 1 end; [Ptr(0):{()}, Ptr(1):{()}, Ptr(2):{()}, Ptr(3):{()}]
-> (); Ptr(4):{1} := !Ptr(4):{1} + 1; Ptr(5):{0} := !Ptr(5):{0} + 1; while !Ptr(5):{0} < 4 do [Ptr(0):{(true, 1)}, Ptr(1):{()}, Ptr(2):{()}, Ptr(3):{()}][!Ptr(5):{0}] := (true, !Ptr(4):{1}); Ptr(4):{1} := !Ptr(4):{1} + 1; Ptr(5):{0} := !Ptr(5):{0} + 1 end; [Ptr(0):{(true, 1)}, Ptr(1):{()}, Ptr(2):{()}, Ptr(3):{()}]
-> Ptr(4):{1} := !Ptr(4):{1} + 1; Ptr(5):{0} := !Ptr(5):{0} + 1; while !Ptr(5):{0} < 4 do [Ptr(0):{(true, 1)}, Ptr(1):{()}, Ptr(2):{()}, Ptr(3):{()}][!Ptr(5):{0}] := (true, !Ptr(4):{1}); Ptr(4):{1} := !Ptr(4):{1} + 1; Ptr(5):{0} := !Ptr(5):{0} + 1 end; [Ptr(0):{(true, 1)}, Ptr(1):{()}, Ptr(2):{()}, Ptr(3):{()}]
-> Ptr(4):{1} := 1 + 1; Ptr(5):{0} := !Ptr(5):{0} + 1; while !Ptr(5):{0} < 4 do [Ptr(0):{(true, 1)}, Ptr(1):{()}, Ptr(2):{()}, Ptr(3):{()}][!Ptr(5):{0}] := (true, !Ptr(4):{1}); Ptr(4):{1} := !Ptr(4):{1} + 1; Ptr(5):{0} := !Ptr(5):{0} + 1 end; [Ptr(0):{(true, 1)}, Ptr(1):{()}, Ptr(2):{()}, Ptr(3):{()}]
-> Ptr(4):{1} := 2; Ptr(5):{0} := !Ptr(5):{0} + 1; while !Ptr(5):{0} < 4 do [Ptr(0):{(true, 1)}, Ptr(1):{()}, Ptr(2):{()}, Ptr(3):{()}][!Ptr(5):{0}] := (true, !Ptr(4):{1}); Ptr(4):{1} := !Ptr(4):{1} + 1; Ptr(5):{0} := !Ptr(5):{0} + 1 end; [Ptr(0):{(true, 1)}, Ptr(1):{()}, Ptr(2):{()}, Ptr(3):{()}]
-> (); Ptr(5):{0} := !Ptr(5):{0} + 1; while !Ptr(5):{0} < 4 do [Ptr(0):{(true, 1)}, Ptr(1):{()}, Ptr(2):{()}, Ptr(3):{()}][!Ptr(5):{0}] := (true, !Ptr(4):{2}); Ptr(4):{2} := !Ptr(4):{2} + 1; Ptr(5):{0} := !Ptr(5):{0} + 1 end; [Ptr(0):{(true, 1)}, Ptr(1):{()}, Ptr(2):{()}, Ptr(3):{()}]
-> Ptr(5):{0} := !Ptr(5):{0} + 1; while !Ptr(5):{0} < 4 do [Ptr(0):{(true, 1)}, Ptr(1):{()}, Ptr(2):{()}, Ptr(3):{()}][!Ptr(5):{0}] := (true, !Ptr(4):{2}); Ptr(4):{2} := !Ptr(4):{2} + 1; Ptr(5):{0} := !Ptr(5):{0} + 1 end; [Ptr(0):{(true, 1)}, Ptr(1):{()}, Ptr(2):{()}, Ptr(3):{()}]
-> Ptr(5):{0} := 0 + 1; while !Ptr(5):{0} < 4 do [Ptr(0):{(true, 1)}, Ptr(1):{()}, Ptr(2):{()}, Ptr(3):{()}][!Ptr(5):{0}] := (true, !Ptr(4):{2}); Ptr(4):{2} := !Ptr(4):{2} + 1; Ptr(5):{0} := !Ptr(5):{0} + 1 end; [Ptr(0):{(true, 1)}, Ptr(1):{()}, Ptr(2):{()}, Ptr(3):{()}]
-> Ptr(5):{0} := 1; while !Ptr(5):{0} < 4 do [Ptr(0):{(true, 1)}, Ptr(1):{()}, Ptr(2):{()}, Ptr(3):{()}][!Ptr(5):{0}] := (true, !Ptr(4):{2}); Ptr(4):{2} := !Ptr(4):{2} + 1; Ptr(5):{0} := !Ptr(5):{0} + 1 end; [Ptr(0):{(true, 1)}, Ptr(1):{()}, Ptr(2):{()}, Ptr(3):{()}]
-> (); while !Ptr(5):{1} < 4 do [Ptr(0):{(true, 1)}, Ptr(1):{()}, Ptr(2):{()}, Ptr(3):{()}][!Ptr(5):{1}] := (true, !Ptr(4):{2}); Ptr(4):{2} := !Ptr(4):{2} + 1; Ptr(5):{1} := !Ptr(5):{1} + 1 end; [Ptr(0):{(true, 1)}, Ptr(1):{()}, Ptr(2):{()}, Ptr(3):{()}]
-> while !Ptr(5):{1} < 4 do [Ptr(0):{(true, 1)}, Ptr(1):{()}, Ptr(2):{()}, Ptr(3):{()}][!Ptr(5):{1}] := (true, !Ptr(4):{2}); Ptr(4):{2} := !Ptr(4):{2} + 1; Ptr(5):{1} := !Ptr(5):{1} + 1 end; [Ptr(0):{(true, 1)}, Ptr(1):{()}, Ptr(2):{()}, Ptr(3):{()}]
-> [Ptr(0):{(true, 1)}, Ptr(1):{()}, Ptr(2):{()}, Ptr(3):{()}][!Ptr(5):{1}] := (true, !Ptr(4):{2}); Ptr(4):{2} := !Ptr(4):{2} + 1; Ptr(5):{1} := !Ptr(5):{1} + 1; while !Ptr(5):{1} < 4 do [Ptr(0):{(true, 1)}, Ptr(1):{()}, Ptr(2):{()}, Ptr(3):{()}][!Ptr(5):{1}] := (true, !Ptr(4):{2}); Ptr(4):{2} := !Ptr(4):{2} + 1; Ptr(5):{1} := !Ptr(5):{1} + 1 end; [Ptr(0):{(true, 1)}, Ptr(1):{()}, Ptr(2):{()}, Ptr(3):{()}]
-> [Ptr(0):{(true, 1)}, Ptr(1):{()}, Ptr(2):{()}, Ptr(3):{()}][1] := (true, !Ptr(4):{2}); Ptr(4):{2} := !Ptr(4):{2} + 1; Ptr(5):{1} := !Ptr(5):{1} + 1; while !Ptr(5):{1} < 4 do [Ptr(0):{(true, 1)}, Ptr(1):{()}, Ptr(2):{()}, Ptr(3):{()}][!Ptr(5):{1}] := (true, !Ptr(4):{2}); Ptr(4):{2} := !Ptr(4):{2} + 1; Ptr(5):{1} := !Ptr(5):{1} + 1 end; [Ptr(0):{(true, 1)}, Ptr(1):{()}, Ptr(2):{()}, Ptr(3):{()}]
-> Ptr(1):{()} := (true, !Ptr(4):{2}); Ptr(4):{2} := !Ptr(4):{2} + 1; Ptr(5):{1} := !Ptr(5):{1} + 1; while !Ptr(5):{1} < 4 do [Ptr(0):{(true, 1)}, Ptr(1):{()}, Ptr(2):{()}, Ptr(3):{()}][!Ptr(5):{1}] := (true, !Ptr(4):{2}); Ptr(4):{2} := !Ptr(4):{2} + 1; Ptr(5):{1} := !Ptr(5):{1} + 1 end; [Ptr(0):{(true, 1)}, Ptr(1):{()}, Ptr(2):{()}, Ptr(3):{()}]
-> Ptr(1):{()} := (true, 2); Ptr(4):{2} := !Ptr(4):{2} + 1; Ptr(5):{1} := !Ptr(5):{1} + 1; while !Ptr(5):{1} < 4 do [Ptr(0):{(true, 1)}, Ptr(1):{()}, Ptr(2):{()}, Ptr(3):{()}][!Ptr(5):{1}] := (true, !Ptr(4):{2}); Ptr(4):{2} := !Ptr(4):{2} + 1; Ptr(5):{1} := !Ptr(5):{1} + 1 end; [Ptr(0):{(true, 1)}, Ptr(1):{()}, Ptr(2):{()}, Ptr(3):{()}]
-> (); Ptr(4):{2} := !Ptr(4):{2} + 1; Ptr(5):{1} := !Ptr(5):{1} + 1; while !Ptr(5):{1} < 4 do [Ptr(0):{(true, 1)}, Ptr(1):{(true, 2)}, Ptr(2):{()}, Ptr(3):{()}][!Ptr(5):{1}] := (true, !Ptr(4):{2}); Ptr(4):{2} := !Ptr(4):{2} + 1; Ptr(5):{1} := !Ptr(5):{1} + 1 end; [Ptr(0):{(true, 1)}, Ptr(1):{(true, 2)}, Ptr(2):{()}, Ptr(3):{()}]
-> Ptr(4):{2} := !Ptr(4):{2} + 1; Ptr(5):{1} := !Ptr(5):{1} + 1; while !Ptr(5):{1} < 4 do [Ptr(0):{(true, 1)}, Ptr(1):{(true, 2)}, Ptr(2):{()}, Ptr(3):{()}][!Ptr(5):{1}] := (true, !Ptr(4):{2}); Ptr(4):{2} := !Ptr(4):{2} + 1; Ptr(5):{1} := !Ptr(5):{1} + 1 end; [Ptr(0):{(true, 1)}, Ptr(1):{(true, 2)}, Ptr(2):{()}, Ptr(3):{()}]
-> Ptr(4):{2} := 2 + 1; Ptr(5):{1} := !Ptr(5):{1} + 1; while !Ptr(5):{1} < 4 do [Ptr(0):{(true, 1)}, Ptr(1):{(true, 2)}, Ptr(2):{()}, Ptr(3):{()}][!Ptr(5):{1}] := (true, !Ptr(4):{2}); Ptr(4):{2} := !Ptr(4):{2} + 1; Ptr(5):{1} := !Ptr(5):{1} + 1 end; [Ptr(0):{(true, 1)}, Ptr(1):{(true, 2)}, Ptr(2):{()}, Ptr(3):{()}]
-> Ptr(4):{2} := 3; Ptr(5):{1} := !Ptr(5):{1} + 1; while !Ptr(5):{1} < 4 do [Ptr(0):{(true, 1)}, Ptr(1):{(true, 2)}, Ptr(2):{()}, Ptr(3):{()}][!Ptr(5):{1}] := (true, !Ptr(4):{2}); Ptr(4):{2} := !Ptr(4):{2} + 1; Ptr(5):{1} := !Ptr(5):{1} + 1 end; [Ptr(0):{(true, 1)}, Ptr(1):{(true, 2)}, Ptr(2):{()}, Ptr(3):{()}]
-> (); Ptr(5):{1} := !Ptr(5):{1} + 1; while !Ptr(5):{1} < 4 do [Ptr(0):{(true, 1)}, Ptr(1):{(true, 2)}, Ptr(2):{()}, Ptr(3):{()}][!Ptr(5):{1}] := (true, !Ptr(4):{3}); Ptr(4):{3} := !Ptr(4):{3} + 1; Ptr(5):{1} := !Ptr(5):{1} + 1 end; [Ptr(0):{(true, 1)}, Ptr(1):{(true, 2)}, Ptr(2):{()}, Ptr(3):{()}]
-> Ptr(5):{1} := !Ptr(5):{1} + 1; while !Ptr(5):{1} < 4 do [Ptr(0):{(true, 1)}, Ptr(1):{(true, 2)}, Ptr(2):{()}, Ptr(3):{()}][!Ptr(5):{1}] := (true, !Ptr(4):{3}); Ptr(4):{3} := !Ptr(4):{3} + 1; Ptr(5):{1} := !Ptr(5):{1} + 1 end; [Ptr(0):{(true, 1)}, Ptr(1):{(true, 2)}, Ptr(2):{()}, Ptr(3):{()}]
-> Ptr(5):{1} := 1 + 1; while !Ptr(5):{1} < 4 do [Ptr(0):{(true, 1)}, Ptr(1):{(true, 2)}, Ptr(2):{()}, Ptr(3):{()}][!Ptr(5):{1}] := (true, !Ptr(4):{3}); Ptr(4):{3} := !Ptr(4):{3} + 1; Ptr(5):{1} := !Ptr(5):{1} + 1 end; [Ptr(0):{(true, 1)}, Ptr(1):{(true, 2)}, Ptr(2):{()}, Ptr(3):{()}]
-> Ptr(5):{1} := 2; while !Ptr(5):{1} < 4 do [Ptr(0):{(true, 1)}, Ptr(1):{(true, 2)}, Ptr(2):{()}, Ptr(3):{()}][!Ptr(5):{1}] := (true, !Ptr(4):{3}); Ptr(4):{3} := !Ptr(4):{3} + 1; Ptr(5):{1} := !Ptr(5):{1} + 1 end; [Ptr(0):{(true, 1)}, Ptr(1):{(true, 2)}, Ptr(2):{()}, Ptr(3):{()}]
-> (); while !Ptr(5):{2} < 4 do [Ptr(0):{(true, 1)}, Ptr(1):{(true, 2)}, Ptr(2):{()}, Ptr(3):{()}][!Ptr(5):{2}] := (true, !Ptr(4):{3}); Ptr(4):{3} := !Ptr(4):{3} + 1; Ptr(5):{2} := !Ptr(5):{2} + 1 end; [Ptr(0):{(true, 1)}, Ptr(1):{(true, 2)}, Ptr(2):{()}, Ptr(3):{()}]
-> while !Ptr(5):{2} < 4 do [Ptr(0):{(true, 1)}, Ptr(1):{(true, 2)}, Ptr(2):{()}, Ptr(3):{()}][!Ptr(5):{2}] := (true, !Ptr(4):{3}); Ptr(4):{3} := !Ptr(4):{3} + 1; Ptr(5):{2} := !Ptr(5):{2} + 1 end; [Ptr(0):{(true, 1)}, Ptr(1):{(true, 2)}, Ptr(2):{()}, Ptr(3):{()}]
-> [Ptr(0):{(true, 1)}, Ptr(1):{(true, 2)}, Ptr(2):{()}, Ptr(3):{()}][!Ptr(5):{2}] := (true, !Ptr(4):{3}); Ptr(4):{3} := !Ptr(4):{3} + 1; Ptr(5):{2} := !Ptr(5):{2} + 1; while !Ptr(5):{2} < 4 do [Ptr(0):{(true, 1)}, Ptr(1):{(true, 2)}, Ptr(2):{()}, Ptr(3):{()}][!Ptr(5):{2}] := (true, !Ptr(4):{3}); Ptr(4):{3} := !Ptr(4):{3} + 1; Ptr(5):{2} := !Ptr(5):{2} + 1 end; [Ptr(0):{(true, 1)}, Ptr(1):{(true, 2)}, Ptr(2):{()}, Ptr(3):{()}]
-> [Ptr(0):{(true, 1)}, Ptr(1):{(true, 2)}, Ptr(2):{()}, Ptr(3):{()}][2] := (true, !Ptr(4):{3}); Ptr(4):{3} := !Ptr(4):{3} + 1; Ptr(5):{2} := !Ptr(5):{2} + 1; while !Ptr(5):{2} < 4 do [Ptr(0):{(true, 1)}, Ptr(1):{(true, 2)}, Ptr(2):{()}, Ptr(3):{()}][!Ptr(5):{2}] := (true, !Ptr(4):{3}); Ptr(4):{3} := !Ptr(4):{3} + 1; Ptr(5):{2} := !Ptr(5):{2} + 1 end; [Ptr(0):{(true, 1)}, Ptr(1):{(true, 2)}, Ptr(2):{()}, Ptr(3):{()}]
-> Ptr(2):{()} := (true, !Ptr(4):{3}); Ptr(4):{3} := !Ptr(4):{3} + 1; Ptr(5):{2} := !Ptr(5):{2} + 1; while !Ptr(5):{2} < 4 do [Ptr(0):{(true, 1)}, Ptr(1):{(true, 2)}, Ptr(2):{()}, Ptr(3):{()}][!Ptr(5):{2}] := (true, !Ptr(4):{3}); Ptr(4):{3} := !Ptr(4):{3} + 1; Ptr(5):{2} := !Ptr(5):{2} + 1 end; [Ptr(0):{(true, 1)}, Ptr(1):{(true, 2)}, Ptr(2):{()}, Ptr(3):{()}]
-> Ptr(2):{()} := (true, 3); Ptr(4):{3} := !Ptr(4):{3} + 1; Ptr(5):{2} := !Ptr(5):{2} + 1; while !Ptr(5):{2} < 4 do [Ptr(0):{(true, 1)}, Ptr(1):{(true, 2)}, Ptr(2):{()}, Ptr(3):{()}][!Ptr(5):{2}] := (true, !Ptr(4):{3}); Ptr(4):{3} := !Ptr(4):{3} + 1; Ptr(5):{2} := !Ptr(5):{2} + 1 end; [Ptr(0):{(true, 1)}, Ptr(1):{(true, 2)}, Ptr(2):{()}, Ptr(3):{()}]
-> (); Ptr(4):{3} := !Ptr(4):{3} + 1; Ptr(5):{2} := !Ptr(5):{2} + 1; while !Ptr(5):{2} < 4 do [Ptr(0):{(true, 1)}, Ptr(1):{(true, 2)}, Ptr(2):{(true, 3)}, Ptr(3):{()}][!Ptr(5):{2}] := (true, !Ptr(4):{3}); Ptr(4):{3} := !Ptr(4):{3} + 1; Ptr(5):{2} := !Ptr(5):{2} + 1 end; [Ptr(0):{(true, 1)}, Ptr(1):{(true, 2)}, Ptr(2):{(true, 3)}, Ptr(3):{()}]
-> Ptr(4):{3} := !Ptr(4):{3} + 1; Ptr(5):{2} := !Ptr(5):{2} + 1; while !Ptr(5):{2} < 4 do [Ptr(0):{(true, 1)}, Ptr(1):{(true, 2)}, Ptr(2):{(true, 3)}, Ptr(3):{()}][!Ptr(5):{2}] := (true, !Ptr(4):{3}); Ptr(4):{3} := !Ptr(4):{3} + 1; Ptr(5):{2} := !Ptr(5):{2} + 1 end; [Ptr(0):{(true, 1)}, Ptr(1):{(true, 2)}, Ptr(2):{(true, 3)}, Ptr(3):{()}]
-> Ptr(4):{3} := 3 + 1; Ptr(5):{2} := !Ptr(5):{2} + 1; while !Ptr(5):{2} < 4 do [Ptr(0):{(true, 1)}, Ptr(1):{(true, 2)}, Ptr(2):{(true, 3)}, Ptr(3):{()}][!Ptr(5):{2}] := (true, !Ptr(4):{3}); Ptr(4):{3} := !Ptr(4):{3} + 1; Ptr(5):{2} := !Ptr(5):{2} + 1 end; [Ptr(0):{(true, 1)}, Ptr(1):{(true, 2)}, Ptr(2):{(true, 3)}, Ptr(3):{()}]
-> Ptr(4):{3} := 4; Ptr(5):{2} := !Ptr(5):{2} + 1; while !Ptr(5):{2} < 4 do [Ptr(0):{(true, 1)}, Ptr(1):{(true, 2)}, Ptr(2):{(true, 3)}, Ptr(3):{()}][!Ptr(5):{2}] := (true, !Ptr(4):{3}); Ptr(4):{3} := !Ptr(4):{3} + 1; Ptr(5):{2} := !Ptr(5):{2} + 1 end; [Ptr(0):{(true, 1)}, Ptr(1):{(true, 2)}, Ptr(2):{(true, 3)}, Ptr(3):{()}]
-> (); Ptr(5):{2} := !Ptr(5):{2} + 1; while !Ptr(5):{2} < 4 do [Ptr(0):{(true, 1)}, Ptr(1):{(true, 2)}, Ptr(2):{(true, 3)}, Ptr(3):{()}][!Ptr(5):{2}] := (true, !Ptr(4):{4}); Ptr(4):{4} := !Ptr(4):{4} + 1; Ptr(5):{2} := !Ptr(5):{2} + 1 end; [Ptr(0):{(true, 1)}, Ptr(1):{(true, 2)}, Ptr(2):{(true, 3)}, Ptr(3):{()}]
-> Ptr(5):{2} := !Ptr(5):{2} + 1; while !Ptr(5):{2} < 4 do [Ptr(0):{(true, 1)}, Ptr(1):{(true, 2)}, Ptr(2):{(true, 3)}, Ptr(3):{()}][!Ptr(5):{2}] := (true, !Ptr(4):{4}); Ptr(4):{4} := !Ptr(4):{4} + 1; Ptr(5):{2} := !Ptr(5):{2} + 1 end; [Ptr(0):{(true, 1)}, Ptr(1):{(true, 2)}, Ptr(2):{(true, 3)}, Ptr(3):{()}]
-> Ptr(5):{2} := 2 + 1; while !Ptr(5):{2} < 4 do [Ptr(0):{(true, 1)}, Ptr(1):{(true, 2)}, Ptr(2):{(true, 3)}, Ptr(3):{()}][!Ptr(5):{2}] := (true, !Ptr(4):{4}); Ptr(4):{4} := !Ptr(4):{4} + 1; Ptr(5):{2} := !Ptr(5):{2} + 1 end; [Ptr(0):{(true, 1)}, Ptr(1):{(true, 2)}, Ptr(2):{(true, 3)}, Ptr(3):{()}]
-> Ptr(5):{2} := 3; while !Ptr(5):{2} < 4 do [Ptr(0):{(true, 1)}, Ptr(1):{(true, 2)}, Ptr(2):{(true, 3)}, Ptr(3):{()}][!Ptr(5):{2}] := (true, !Ptr(4):{4}); Ptr(4):{4} := !Ptr(4):{4} + 1; Ptr(5):{2} := !Ptr(5):{2} + 1 end; [Ptr(0):{(true, 1)}, Ptr(1):{(true, 2)}, Ptr(2):{(true, 3)}, Ptr(3):{()}]
-> (); while !Ptr(5):{3} < 4 do [Ptr(0):{(true, 1)}, Ptr(1):{(true, 2)}, Ptr(2):{(true, 3)}, Ptr(3):{()}][!Ptr(5):{3}] := (true, !Ptr(4):{4}); Ptr(4):{4} := !Ptr(4):{4} + 1; Ptr(5):{3} := !Ptr(5):{3} + 1 end; [Ptr(0):{(true, 1)}, Ptr(1):{(true, 2)}, Ptr(2):{(true, 3)}, Ptr(3):{()}]
-> while !Ptr(5):{3} < 4 do [Ptr(0):{(true, 1)}, Ptr(1):{(true, 2)}, Ptr(2):{(true, 3)}, Ptr(3):{()}][!Ptr(5):{3}] := (true, !Ptr(4):{4}); Ptr(4):{4} := !Ptr(4):{4} + 1; Ptr(5):{3} := !Ptr(5):{3} + 1 end; [Ptr(0):{(true, 1)}, Ptr(1):{(true, 2)}, Ptr(2):{(true, 3)}, Ptr(3):{()}]
-> [Ptr(0):{(true, 1)}, Ptr(1):{(true, 2)}, Ptr(2):{(true, 3)}, Ptr(3):{()}][!Ptr(5):{3}] := (true, !Ptr(4):{4}); Ptr(4):{4} := !Ptr(4):{4} + 1; Ptr(5):{3} := !Ptr(5):{3} + 1; while !Ptr(5):{3} < 4 do [Ptr(0):{(true, 1)}, Ptr(1):{(true, 2)}, Ptr(2):{(true, 3)}, Ptr(3):{()}][!Ptr(5):{3}] := (true, !Ptr(4):{4}); Ptr(4):{4} := !Ptr(4):{4} + 1; Ptr(5):{3} := !Ptr(5):{3} + 1 end; [Ptr(0):{(true, 1)}, Ptr(1):{(true, 2)}, Ptr(2):{(true, 3)}, Ptr(3):{()}]
-> [Ptr(0):{(true, 1)}, Ptr(1):{(true, 2)}, Ptr(2):{(true, 3)}, Ptr(3):{()}][3] := (true, !Ptr(4):{4}); Ptr(4):{4} := !Ptr(4):{4} + 1; Ptr(5):{3} := !Ptr(5):{3} + 1; while !Ptr(5):{3} < 4 do [Ptr(0):{(true, 1)}, Ptr(1):{(true, 2)}, Ptr(2):{(true, 3)}, Ptr(3):{()}][!Ptr(5):{3}] := (true, !Ptr(4):{4}); Ptr(4):{4} := !Ptr(4):{4} + 1; Ptr(5):{3} := !Ptr(5):{3} + 1 end; [Ptr(0):{(true, 1)}, Ptr(1):{(true, 2)}, Ptr(2):{(true, 3)}, Ptr(3):{()}]
-> Ptr(3):{()} := (true, !Ptr(4):{4}); Ptr(4):{4} := !Ptr(4):{4} + 1; Ptr(5):{3} := !Ptr(5):{3} + 1; while !Ptr(5):{3} < 4 do [Ptr(0):{(true, 1)}, Ptr(1):{(true, 2)}, Ptr(2):{(true, 3)}, Ptr(3):{()}][!Ptr(5):{3}] := (true, !Ptr(4):{4}); Ptr(4):{4} := !Ptr(4):{4} + 1; Ptr(5):{3} := !Ptr(5):{3} + 1 end; [Ptr(0):{(true, 1)}, Ptr(1):{(true, 2)}, Ptr(2):{(true, 3)}, Ptr(3):{()}]
-> Ptr(3):{()} := (true, 4); Ptr(4):{4} := !Ptr(4):{4} + 1; Ptr(5):{3} := !Ptr(5):{3} + 1; while !Ptr(5):{3} < 4 do [Ptr(0):{(true, 1)}, Ptr(1):{(true, 2)}, Ptr(2):{(true, 3)}, Ptr(3):{()}][!Ptr(5):{3}] := (true, !Ptr(4):{4}); Ptr(4):{4} := !Ptr(4):{4} + 1; Ptr(5):{3} := !Ptr(5):{3} + 1 end; [Ptr(0):{(true, 1)}, Ptr(1):{(true, 2)}, Ptr(2):{(true, 3)}, Ptr(3):{()}]
-> (); Ptr(4):{4} := !Ptr(4):{4} + 1; Ptr(5):{3} := !Ptr(5):{3} + 1; while !Ptr(5):{3} < 4 do [Ptr(0):{(true, 1)}, Ptr(1):{(true, 2)}, Ptr(2):{(true, 3)}, Ptr(3):{(true, 4)}][!Ptr(5):{3}] := (true, !Ptr(4):{4}); Ptr(4):{4} := !Ptr(4):{4} + 1; Ptr(5):{3} := !Ptr(5):{3} + 1 end; [Ptr(0):{(true, 1)}, Ptr(1):{(true, 2)}, Ptr(2):{(true, 3)}, Ptr(3):{(true, 4)}]
-> Ptr(4):{4} := !Ptr(4):{4} + 1; Ptr(5):{3} := !Ptr(5):{3} + 1; while !Ptr(5):{3} < 4 do [Ptr(0):{(true, 1)}, Ptr(1):{(true, 2)}, Ptr(2):{(true, 3)}, Ptr(3):{(true, 4)}][!Ptr(5):{3}] := (true, !Ptr(4):{4}); Ptr(4):{4} := !Ptr(4):{4} + 1; Ptr(5):{3} := !Ptr(5):{3} + 1 end; [Ptr(0):{(true, 1)}, Ptr(1):{(true, 2)}, Ptr(2):{(true, 3)}, Ptr(3):{(true, 4)}]
-> Ptr(4):{4} := 4 + 1; Ptr(5):{3} := !Ptr(5):{3} + 1; while !Ptr(5):{3} < 4 do [Ptr(0):{(true, 1)}, Ptr(1):{(true, 2)}, Ptr(2):{(true, 3)}, Ptr(3):{(true, 4)}][!Ptr(5):{3}] := (true, !Ptr(4):{4}); Ptr(4):{4} := !Ptr(4):{4} + 1; Ptr(5):{3} := !Ptr(5):{3} + 1 end; [Ptr(0):{(true, 1)}, Ptr(1):{(true, 2)}, Ptr(2):{(true, 3)}, Ptr(3):{(true, 4)}]
-> Ptr(4):{4} := 5; Ptr(5):{3} := !Ptr(5):{3} + 1; while !Ptr(5):{3} < 4 do [Ptr(0):{(true, 1)}, Ptr(1):{(true, 2)}, Ptr(2):{(true, 3)}, Ptr(3):{(true, 4)}][!Ptr(5):{3}] := (true, !Ptr(4):{4}); Ptr(4):{4} := !Ptr(4):{4} + 1; Ptr(5):{3} := !Ptr(5):{3} + 1 end; [Ptr(0):{(true, 1)}, Ptr(1):{(true, 2)}, Ptr(2):{(true, 3)}, Ptr(3):{(true, 4)}]
-> (); Ptr(5):{3} := !Ptr(5):{3} + 1; while !Ptr(5):{3} < 4 do [Ptr(0):{(true, 1)}, Ptr(1):{(true, 2)}, Ptr(2):{(true, 3)}, Ptr(3):{(true, 4)}][!Ptr(5):{3}] := (true, !Ptr(4):{5}); Ptr(4):{5} := !Ptr(4):{5} + 1; Ptr(5):{3} := !Ptr(5):{3} + 1 end; [Ptr(0):{(true, 1)}, Ptr(1):{(true, 2)}, Ptr(2):{(true, 3)}, Ptr(3):{(true, 4)}]
-> Ptr(5):{3} := !Ptr(5):{3} + 1; while !Ptr(5):{3} < 4 do [Ptr(0):{(true, 1)}, Ptr(1):{(true, 2)}, Ptr(2):{(true, 3)}, Ptr(3):{(true, 4)}][!Ptr(5):{3}] := (true, !Ptr(4):{5}); Ptr(4):{5} := !Ptr(4):{5} + 1; Ptr(5):{3} := !Ptr(5):{3} + 1 end; [Ptr(0):{(true, 1)}, Ptr(1):{(true, 2)}, Ptr(2):{(true, 3)}, Ptr(3):{(true, 4)}]
-> Ptr(5):{3} := 3 + 1; while !Ptr(5):{3} < 4 do [Ptr(0):{(true, 1)}, Ptr(1):{(true, 2)}, Ptr(2):{(true, 3)}, Ptr(3):{(true, 4)}][!Ptr(5):{3}] := (true, !Ptr(4):{5}); Ptr(4):{5} := !Ptr(4):{5} + 1; Ptr(5):{3} := !Ptr(5):{3} + 1 end; [Ptr(0):{(true, 1)}, Ptr(1):{(true, 2)}, Ptr(2):{(true, 3)}, Ptr(3):{(true, 4)}]
-> Ptr(5):{3} := 4; while !Ptr(5):{3} < 4 do [Ptr(0):{(true, 1)}, Ptr(1):{(true, 2)}, Ptr(2):{(true, 3)}, Ptr(3):{(true, 4)}][!Ptr(5):{3}] := (true, !Ptr(4):{5}); Ptr(4):{5} := !Ptr(4):{5} + 1; Ptr(5):{3} := !Ptr(5):{3} + 1 end; [Ptr(0):{(true, 1)}, Ptr(1):{(true, 2)}, Ptr(2):{(true, 3)}, Ptr(3):{(true, 4)}]
-> (); while !Ptr(5):{4} < 4 do [Ptr(0):{(true, 1)}, Ptr(1):{(true, 2)}, Ptr(2):{(true, 3)}, Ptr(3):{(true, 4)}][!Ptr(5):{4}] := (true, !Ptr(4):{5}); Ptr(4):{5} := !Ptr(4):{5} + 1; Ptr(5):{4} := !Ptr(5):{4} + 1 end; [Ptr(0):{(true, 1)}, Ptr(1):{(true, 2)}, Ptr(2):{(true, 3)}, Ptr(3):{(true, 4)}]
-> while !Ptr(5):{4} < 4 do [Ptr(0):{(true, 1)}, Ptr(1):{(true, 2)}, Ptr(2):{(true, 3)}, Ptr(3):{(true, 4)}][!Ptr(5):{4}] := (true, !Ptr(4):{5}); Ptr(4):{5} := !Ptr(4):{5} + 1; Ptr(5):{4} := !Ptr(5):{4} + 1 end; [Ptr(0):{(true, 1)}, Ptr(1):{(true, 2)}, Ptr(2):{(true, 3)}, Ptr(3):{(true, 4)}]
-> (); [Ptr(0):{(true, 1)}, Ptr(1):{(true, 2)}, Ptr(2):{(true, 3)}, Ptr(3):{(true, 4)}]
-> [Ptr(0):{(true, 1)}, Ptr(1):{(true, 2)}, Ptr(2):{(true, 3)}, Ptr(3):{(true, 4)}]
===== test57 =====
[Ptr(0):{true}, Ptr(1):{true}, Ptr(2):{true}, Ptr(3):{true}]
===== test58 =====
[let,n,:,int,=,4,in,let,x,:,array,<,bool,>,=,new,bool,[,n,],in,let,count,:,<,int,>,=,ref,0,in,while,!,count,<,n,do,(,x,[,!,count,],:=,true,),;,count,:=,!,count,+,1,end,;,x]
===== test59 =====
let n : int = 4 in let x : array<bool> = new bool[n] in let count : <int> = ref 0 in while !count < n do x[!count] := true; count := !count + 1 end; x
===== test60 =====
-> let n : int = 4 in let x : array<bool> = new bool[n] in let count : <int> = ref 0 in while !count < n do x[!count] := true; count := !count + 1 end; x
-> let x : array<bool> = new bool[4] in let count : <int> = ref 0 in while !count < 4 do x[!count] := true; count := !count + 1 end; x
-> let x : array<bool> = [Ptr(0):{()}, Ptr(1):{()}, Ptr(2):{()}, Ptr(3):{()}] in let count : <int> = ref 0 in while !count < 4 do x[!count] := true; count := !count + 1 end; x
-> let count : <int> = ref 0 in while !count < 4 do [Ptr(0):{()}, Ptr(1):{()}, Ptr(2):{()}, Ptr(3):{()}][!count] := true; count := !count + 1 end; [Ptr(0):{()}, Ptr(1):{()}, Ptr(2):{()}, Ptr(3):{()}]
-> let count : <int> = Ptr(4):{0} in while !count < 4 do [Ptr(0):{()}, Ptr(1):{()}, Ptr(2):{()}, Ptr(3):{()}][!count] := true; count := !count + 1 end; [Ptr(0):{()}, Ptr(1):{()}, Ptr(2):{()}, Ptr(3):{()}]
-> while !Ptr(4):{0} < 4 do [Ptr(0):{()}, Ptr(1):{()}, Ptr(2):{()}, Ptr(3):{()}][!Ptr(4):{0}] := true; Ptr(4):{0} := !Ptr(4):{0} + 1 end; [Ptr(0):{()}, Ptr(1):{()}, Ptr(2):{()}, Ptr(3):{()}]
-> [Ptr(0):{()}, Ptr(1):{()}, Ptr(2):{()}, Ptr(3):{()}][!Ptr(4):{0}] := true; Ptr(4):{0} := !Ptr(4):{0} + 1; while !Ptr(4):{0} < 4 do [Ptr(0):{()}, Ptr(1):{()}, Ptr(2):{()}, Ptr(3):{()}][!Ptr(4):{0}] := true; Ptr(4):{0} := !Ptr(4):{0} + 1 end; [Ptr(0):{()}, Ptr(1):{()}, Ptr(2):{()}, Ptr(3):{()}]
-> [Ptr(0):{()}, Ptr(1):{()}, Ptr(2):{()}, Ptr(3):{()}][0] := true; Ptr(4):{0} := !Ptr(4):{0} + 1; while !Ptr(4):{0} < 4 do [Ptr(0):{()}, Ptr(1):{()}, Ptr(2):{()}, Ptr(3):{()}][!Ptr(4):{0}] := true; Ptr(4):{0} := !Ptr(4):{0} + 1 end; [Ptr(0):{()}, Ptr(1):{()}, Ptr(2):{()}, Ptr(3):{()}]
-> Ptr(0):{()} := true; Ptr(4):{0} := !Ptr(4):{0} + 1; while !Ptr(4):{0} < 4 do [Ptr(0):{()}, Ptr(1):{()}, Ptr(2):{()}, Ptr(3):{()}][!Ptr(4):{0}] := true; Ptr(4):{0} := !Ptr(4):{0} + 1 end; [Ptr(0):{()}, Ptr(1):{()}, Ptr(2):{()}, Ptr(3):{()}]
-> (); Ptr(4):{0} := !Ptr(4):{0} + 1; while !Ptr(4):{0} < 4 do [Ptr(0):{true}, Ptr(1):{()}, Ptr(2):{()}, Ptr(3):{()}][!Ptr(4):{0}] := true; Ptr(4):{0} := !Ptr(4):{0} + 1 end; [Ptr(0):{true}, Ptr(1):{()}, Ptr(2):{()}, Ptr(3):{()}]
-> Ptr(4):{0} := !Ptr(4):{0} + 1; while !Ptr(4):{0} < 4 do [Ptr(0):{true}, Ptr(1):{()}, Ptr(2):{()}, Ptr(3):{()}][!Ptr(4):{0}] := true; Ptr(4):{0} := !Ptr(4):{0} + 1 end; [Ptr(0):{true}, Ptr(1):{()}, Ptr(2):{()}, Ptr(3):{()}]
-> Ptr(4):{0} := 0 + 1; while !Ptr(4):{0} < 4 do [Ptr(0):{true}, Ptr(1):{()}, Ptr(2):{()}, Ptr(3):{()}][!Ptr(4):{0}] := true; Ptr(4):{0} := !Ptr(4):{0} + 1 end; [Ptr(0):{true}, Ptr(1):{()}, Ptr(2):{()}, Ptr(3):{()}]
-> Ptr(4):{0} := 1; while !Ptr(4):{0} < 4 do [Ptr(0):{true}, Ptr(1):{()}, Ptr(2):{()}, Ptr(3):{()}][!Ptr(4):{0}] := true; Ptr(4):{0} := !Ptr(4):{0} + 1 end; [Ptr(0):{true}, Ptr(1):{()}, Ptr(2):{()}, Ptr(3):{()}]
-> (); while !Ptr(4):{1} < 4 do [Ptr(0):{true}, Ptr(1):{()}, Ptr(2):{()}, Ptr(3):{()}][!Ptr(4):{1}] := true; Ptr(4):{1} := !Ptr(4):{1} + 1 end; [Ptr(0):{true}, Ptr(1):{()}, Ptr(2):{()}, Ptr(3):{()}]
-> while !Ptr(4):{1} < 4 do [Ptr(0):{true}, Ptr(1):{()}, Ptr(2):{()}, Ptr(3):{()}][!Ptr(4):{1}] := true; Ptr(4):{1} := !Ptr(4):{1} + 1 end; [Ptr(0):{true}, Ptr(1):{()}, Ptr(2):{()}, Ptr(3):{()}]
-> [Ptr(0):{true}, Ptr(1):{()}, Ptr(2):{()}, Ptr(3):{()}][!Ptr(4):{1}] := true; Ptr(4):{1} := !Ptr(4):{1} + 1; while !Ptr(4):{1} < 4 do [Ptr(0):{true}, Ptr(1):{()}, Ptr(2):{()}, Ptr(3):{()}][!Ptr(4):{1}] := true; Ptr(4):{1} := !Ptr(4):{1} + 1 end; [Ptr(0):{true}, Ptr(1):{()}, Ptr(2):{()}, Ptr(3):{()}]
-> [Ptr(0):{true}, Ptr(1):{()}, Ptr(2):{()}, Ptr(3):{()}][1] := true; Ptr(4):{1} := !Ptr(4):{1} + 1; while !Ptr(4):{1} < 4 do [Ptr(0):{true}, Ptr(1):{()}, Ptr(2):{()}, Ptr(3):{()}][!Ptr(4):{1}] := true; Ptr(4):{1} := !Ptr(4):{1} + 1 end; [Ptr(0):{true}, Ptr(1):{()}, Ptr(2):{()}, Ptr(3):{()}]
-> Ptr(1):{()} := true; Ptr(4):{1} := !Ptr(4):{1} + 1; while !Ptr(4):{1} < 4 do [Ptr(0):{true}, Ptr(1):{()}, Ptr(2):{()}, Ptr(3):{()}][!Ptr(4):{1}] := true; Ptr(4):{1} := !Ptr(4):{1} + 1 end; [Ptr(0):{true}, Ptr(1):{()}, Ptr(2):{()}, Ptr(3):{()}]
-> (); Ptr(4):{1} := !Ptr(4):{1} + 1; while !Ptr(4):{1} < 4 do [Ptr(0):{true}, Ptr(1):{true}, Ptr(2):{()}, Ptr(3):{()}][!Ptr(4):{1}] := true; Ptr(4):{1} := !Ptr(4):{1} + 1 end; [Ptr(0):{true}, Ptr(1):{true}, Ptr(2):{()}, Ptr(3):{()}]
-> Ptr(4):{1} := !Ptr(4):{1} + 1; while !Ptr(4):{1} < 4 do [Ptr(0):{true}, Ptr(1):{true}, Ptr(2):{()}, Ptr(3):{()}][!Ptr(4):{1}] := true; Ptr(4):{1} := !Ptr(4):{1} + 1 end; [Ptr(0):{true}, Ptr(1):{true}, Ptr(2):{()}, Ptr(3):{()}]
-> Ptr(4):{1} := 1 + 1; while !Ptr(4):{1} < 4 do [Ptr(0):{true}, Ptr(1):{true}, Ptr(2):{()}, Ptr(3):{()}][!Ptr(4):{1}] := true; Ptr(4):{1} := !Ptr(4):{1} + 1 end; [Ptr(0):{true}, Ptr(1):{true}, Ptr(2):{()}, Ptr(3):{()}]
-> Ptr(4):{1} := 2; while !Ptr(4):{1} < 4 do [Ptr(0):{true}, Ptr(1):{true}, Ptr(2):{()}, Ptr(3):{()}][!Ptr(4):{1}] := true; Ptr(4):{1} := !Ptr(4):{1} + 1 end; [Ptr(0):{true}, Ptr(1):{true}, Ptr(2):{()}, Ptr(3):{()}]
-> (); while !Ptr(4):{2} < 4 do [Ptr(0):{true}, Ptr(1):{true}, Ptr(2):{()}, Ptr(3):{()}][!Ptr(4):{2}] := true; Ptr(4):{2} := !Ptr(4):{2} + 1 end; [Ptr(0):{true}, Ptr(1):{true}, Ptr(2):{()}, Ptr(3):{()}]
-> while !Ptr(4):{2} < 4 do [Ptr(0):{true}, Ptr(1):{true}, Ptr(2):{()}, Ptr(3):{()}][!Ptr(4):{2}] := true; Ptr(4):{2} := !Ptr(4):{2} + 1 end; [Ptr(0):{true}, Ptr(1):{true}, Ptr(2):{()}, Ptr(3):{()}]
-> [Ptr(0):{true}, Ptr(1):{true}, Ptr(2):{()}, Ptr(3):{()}][!Ptr(4):{2}] := true; Ptr(4):{2} := !Ptr(4):{2} + 1; while !Ptr(4):{2} < 4 do [Ptr(0):{true}, Ptr(1):{true}, Ptr(2):{()}, Ptr(3):{()}][!Ptr(4):{2}] := true; Ptr(4):{2} := !Ptr(4):{2} + 1 end; [Ptr(0):{true}, Ptr(1):{true}, Ptr(2):{()}, Ptr(3):{()}]
-> [Ptr(0):{true}, Ptr(1):{true}, Ptr(2):{()}, Ptr(3):{()}][2] := true; Ptr(4):{2} := !Ptr(4):{2} + 1; while !Ptr(4):{2} < 4 do [Ptr(0):{true}, Ptr(1):{true}, Ptr(2):{()}, Ptr(3):{()}][!Ptr(4):{2}] := true; Ptr(4):{2} := !Ptr(4):{2} + 1 end; [Ptr(0):{true}, Ptr(1):{true}, Ptr(2):{()}, Ptr(3):{()}]
-> Ptr(2):{()} := true; Ptr(4):{2} := !Ptr(4):{2} + 1; while !Ptr(4):{2} < 4 do [Ptr(0):{true}, Ptr(1):{true}, Ptr(2):{()}, Ptr(3):{()}][!Ptr(4):{2}] := true; Ptr(4):{2} := !Ptr(4):{2} + 1 end; [Ptr(0):{true}, Ptr(1):{true}, Ptr(2):{()}, Ptr(3):{()}]
-> (); Ptr(4):{2} := !Ptr(4):{2} + 1; while !Ptr(4):{2} < 4 do [Ptr(0):{true}, Ptr(1):{true}, Ptr(2):{true}, Ptr(3):{()}][!Ptr(4):{2}] := true; Ptr(4):{2} := !Ptr(4):{2} + 1 end; [Ptr(0):{true}, Ptr(1):{true}, Ptr(2):{true}, Ptr(3):{()}]
-> Ptr(4):{2} := !Ptr(4):{2} + 1; while !Ptr(4):{2} < 4 do [Ptr(0):{true}, Ptr(1):{true}, Ptr(2):{true}, Ptr(3):{()}][!Ptr(4):{2}] := true; Ptr(4):{2} := !Ptr(4):{2} + 1 end; [Ptr(0):{true}, Ptr(1):{true}, Ptr(2):{true}, Ptr(3):{()}]
-> Ptr(4):{2} := 2 + 1; while !Ptr(4):{2} < 4 do [Ptr(0):{true}, Ptr(1):{true}, Ptr(2):{true}, Ptr(3):{()}][!Ptr(4):{2}] := true; Ptr(4):{2} := !Ptr(4):{2} + 1 end; [Ptr(0):{true}, Ptr(1):{true}, Ptr(2):{true}, Ptr(3):{()}]
-> Ptr(4):{2} := 3; while !Ptr(4):{2} < 4 do [Ptr(0):{true}, Ptr(1):{true}, Ptr(2):{true}, Ptr(3):{()}][!Ptr(4):{2}] := true; Ptr(4):{2} := !Ptr(4):{2} + 1 end; [Ptr(0):{true}, Ptr(1):{true}, Ptr(2):{true}, Ptr(3):{()}]
-> (); while !Ptr(4):{3} < 4 do [Ptr(0):{true}, Ptr(1):{true}, Ptr(2):{true}, Ptr(3):{()}][!Ptr(4):{3}] := true; Ptr(4):{3} := !Ptr(4):{3} + 1 end; [Ptr(0):{true}, Ptr(1):{true}, Ptr(2):{true}, Ptr(3):{()}]
-> while !Ptr(4):{3} < 4 do [Ptr(0):{true}, Ptr(1):{true}, Ptr(2):{true}, Ptr(3):{()}][!Ptr(4):{3}] := true; Ptr(4):{3} := !Ptr(4):{3} + 1 end; [Ptr(0):{true}, Ptr(1):{true}, Ptr(2):{true}, Ptr(3):{()}]
-> [Ptr(0):{true}, Ptr(1):{true}, Ptr(2):{true}, Ptr(3):{()}][!Ptr(4):{3}] := true; Ptr(4):{3} := !Ptr(4):{3} + 1; while !Ptr(4):{3} < 4 do [Ptr(0):{true}, Ptr(1):{true}, Ptr(2):{true}, Ptr(3):{()}][!Ptr(4):{3}] := true; Ptr(4):{3} := !Ptr(4):{3} + 1 end; [Ptr(0):{true}, Ptr(1):{true}, Ptr(2):{true}, Ptr(3):{()}]
-> [Ptr(0):{true}, Ptr(1):{true}, Ptr(2):{true}, Ptr(3):{()}][3] := true; Ptr(4):{3} := !Ptr(4):{3} + 1; while !Ptr(4):{3} < 4 do [Ptr(0):{true}, Ptr(1):{true}, Ptr(2):{true}, Ptr(3):{()}][!Ptr(4):{3}] := true; Ptr(4):{3} := !Ptr(4):{3} + 1 end; [Ptr(0):{true}, Ptr(1):{true}, Ptr(2):{true}, Ptr(3):{()}]
-> Ptr(3):{()} := true; Ptr(4):{3} := !Ptr(4):{3} + 1; while !Ptr(4):{3} < 4 do [Ptr(0):{true}, Ptr(1):{true}, Ptr(2):{true}, Ptr(3):{()}][!Ptr(4):{3}] := true; Ptr(4):{3} := !Ptr(4):{3} + 1 end; [Ptr(0):{true}, Ptr(1):{true}, Ptr(2):{true}, Ptr(3):{()}]
-> (); Ptr(4):{3} := !Ptr(4):{3} + 1; while !Ptr(4):{3} < 4 do [Ptr(0):{true}, Ptr(1):{true}, Ptr(2):{true}, Ptr(3):{true}][!Ptr(4):{3}] := true; Ptr(4):{3} := !Ptr(4):{3} + 1 end; [Ptr(0):{true}, Ptr(1):{true}, Ptr(2):{true}, Ptr(3):{true}]
-> Ptr(4):{3} := !Ptr(4):{3} + 1; while !Ptr(4):{3} < 4 do [Ptr(0):{true}, Ptr(1):{true}, Ptr(2):{true}, Ptr(3):{true}][!Ptr(4):{3}] := true; Ptr(4):{3} := !Ptr(4):{3} + 1 end; [Ptr(0):{true}, Ptr(1):{true}, Ptr(2):{true}, Ptr(3):{true}]
-> Ptr(4):{3} := 3 + 1; while !Ptr(4):{3} < 4 do [Ptr(0):{true}, Ptr(1):{true}, Ptr(2):{true}, Ptr(3):{true}][!Ptr(4):{3}] := true; Ptr(4):{3} := !Ptr(4):{3} + 1 end; [Ptr(0):{true}, Ptr(1):{true}, Ptr(2):{true}, Ptr(3):{true}]
-> Ptr(4):{3} := 4; while !Ptr(4):{3} < 4 do [Ptr(0):{true}, Ptr(1):{true}, Ptr(2):{true}, Ptr(3):{true}][!Ptr(4):{3}] := true; Ptr(4):{3} := !Ptr(4):{3} + 1 end; [Ptr(0):{true}, Ptr(1):{true}, Ptr(2):{true}, Ptr(3):{true}]
-> (); while !Ptr(4):{4} < 4 do [Ptr(0):{true}, Ptr(1):{true}, Ptr(2):{true}, Ptr(3):{true}][!Ptr(4):{4}] := true; Ptr(4):{4} := !Ptr(4):{4} + 1 end; [Ptr(0):{true}, Ptr(1):{true}, Ptr(2):{true}, Ptr(3):{true}]
-> while !Ptr(4):{4} < 4 do [Ptr(0):{true}, Ptr(1):{true}, Ptr(2):{true}, Ptr(3):{true}][!Ptr(4):{4}] := true; Ptr(4):{4} := !Ptr(4):{4} + 1 end; [Ptr(0):{true}, Ptr(1):{true}, Ptr(2):{true}, Ptr(3):{true}]
-> (); [Ptr(0):{true}, Ptr(1):{true}, Ptr(2):{true}, Ptr(3):{true}]
-> [Ptr(0):{true}, Ptr(1):{true}, Ptr(2):{true}, Ptr(3):{true}]
===== test61 =====
true
===== test62 =====
[let,count,:,<,bool,>,=,ref,true,in,!,count]
===== test63 =====
let count : <bool> = ref true in !count
===== test64 =====
-> let count : <bool> = ref true in !count
-> let count : <bool> = Ptr(0):{true} in !count
-> !Ptr(0):{true}
-> true
===== test65 =====
(false, 4)
===== test66 =====
[let,count,:,<,bool,*,int,>,=,ref,(,false,,,4,),in,!,count]
===== test67 =====
let count : <(bool * int)> = ref (false, 4) in !count
===== test68 =====
-> let count : <(bool * int)> = ref (false, 4) in !count
-> let count : <(bool * int)> = Ptr(0):{(false, 4)} in !count
-> !Ptr(0):{(false, 4)}
-> (false, 4)
===== test69 =====
3
===== test70 =====
[let,min,:,<,int,->,(,int,list,->,int,),>,=,ref,fix,f,(,cur,:,int,),:,(,int,list,->,int,),->,fun,(,l,:,int,list,),:,int,->,if,(,empty,l,),then,cur,else,if,(,hd,l,),<,cur,then,f,(,hd,l,),(,tl,l,),else,f,(,cur,),(,tl,l,),in,!,min,(,100,),(,10,::,20,::,5,::,70,::,3,::,80,::,1000,::,[,],:,int,)]
===== test71 =====
let min : <(int -> (int list -> int))> = ref fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) in !min (100) (10 :: 20 :: 5 :: 70 :: 3 :: 80 :: 1000 :: [] : int)
===== test72 =====
-> let min : <(int -> (int list -> int))> = ref fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) in !min (100) (10 :: 20 :: 5 :: 70 :: 3 :: 80 :: 1000 :: [] : int)
-> let min : <(int -> (int list -> int))> = Ptr(0):{fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l)} in !min (100) (10 :: 20 :: 5 :: 70 :: 3 :: 80 :: 1000 :: [] : int)
-> !Ptr(0):{fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l)} (100) (10 :: 20 :: 5 :: 70 :: 3 :: 80 :: 1000 :: [] : int)
-> fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (100) (10 :: 20 :: 5 :: 70 :: 3 :: 80 :: 1000 :: [] : int)
-> fun (l:int list) : int -> if empty l then 100 else if hd l < 100 then fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (hd l) (tl l) else fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (100) (tl l) (10 :: 20 :: 5 :: 70 :: 3 :: 80 :: 1000 :: [] : int)
-> if empty 10 :: 20 :: 5 :: 70 :: 3 :: 80 :: 1000 :: [] : int then 100 else if hd 10 :: 20 :: 5 :: 70 :: 3 :: 80 :: 1000 :: [] : int < 100 then fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (hd 10 :: 20 :: 5 :: 70 :: 3 :: 80 :: 1000 :: [] : int) (tl 10 :: 20 :: 5 :: 70 :: 3 :: 80 :: 1000 :: [] : int) else fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (100) (tl 10 :: 20 :: 5 :: 70 :: 3 :: 80 :: 1000 :: [] : int)
-> if false then 100 else if hd 10 :: 20 :: 5 :: 70 :: 3 :: 80 :: 1000 :: [] : int < 100 then fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (hd 10 :: 20 :: 5 :: 70 :: 3 :: 80 :: 1000 :: [] : int) (tl 10 :: 20 :: 5 :: 70 :: 3 :: 80 :: 1000 :: [] : int) else fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (100) (tl 10 :: 20 :: 5 :: 70 :: 3 :: 80 :: 1000 :: [] : int)
-> if 10 < 100 then fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (hd 10 :: 20 :: 5 :: 70 :: 3 :: 80 :: 1000 :: [] : int) (tl 10 :: 20 :: 5 :: 70 :: 3 :: 80 :: 1000 :: [] : int) else fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (100) (tl 10 :: 20 :: 5 :: 70 :: 3 :: 80 :: 1000 :: [] : int)
-> if true then fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (hd 10 :: 20 :: 5 :: 70 :: 3 :: 80 :: 1000 :: [] : int) (tl 10 :: 20 :: 5 :: 70 :: 3 :: 80 :: 1000 :: [] : int) else fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (100) (tl 10 :: 20 :: 5 :: 70 :: 3 :: 80 :: 1000 :: [] : int)
-> fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (10) (tl 10 :: 20 :: 5 :: 70 :: 3 :: 80 :: 1000 :: [] : int)
-> fun (l:int list) : int -> if empty l then 10 else if hd l < 10 then fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (hd l) (tl l) else fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (10) (tl l) (tl 10 :: 20 :: 5 :: 70 :: 3 :: 80 :: 1000 :: [] : int)
-> fun (l:int list) : int -> if empty l then 10 else if hd l < 10 then fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (hd l) (tl l) else fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (10) (tl l) (20 :: 5 :: 70 :: 3 :: 80 :: 1000 :: [] : int)
-> if empty 20 :: 5 :: 70 :: 3 :: 80 :: 1000 :: [] : int then 10 else if hd 20 :: 5 :: 70 :: 3 :: 80 :: 1000 :: [] : int < 10 then fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (hd 20 :: 5 :: 70 :: 3 :: 80 :: 1000 :: [] : int) (tl 20 :: 5 :: 70 :: 3 :: 80 :: 1000 :: [] : int) else fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (10) (tl 20 :: 5 :: 70 :: 3 :: 80 :: 1000 :: [] : int)
-> if false then 10 else if hd 20 :: 5 :: 70 :: 3 :: 80 :: 1000 :: [] : int < 10 then fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (hd 20 :: 5 :: 70 :: 3 :: 80 :: 1000 :: [] : int) (tl 20 :: 5 :: 70 :: 3 :: 80 :: 1000 :: [] : int) else fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (10) (tl 20 :: 5 :: 70 :: 3 :: 80 :: 1000 :: [] : int)
-> if 20 < 10 then fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (hd 20 :: 5 :: 70 :: 3 :: 80 :: 1000 :: [] : int) (tl 20 :: 5 :: 70 :: 3 :: 80 :: 1000 :: [] : int) else fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (10) (tl 20 :: 5 :: 70 :: 3 :: 80 :: 1000 :: [] : int)
-> if false then fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (hd 20 :: 5 :: 70 :: 3 :: 80 :: 1000 :: [] : int) (tl 20 :: 5 :: 70 :: 3 :: 80 :: 1000 :: [] : int) else fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (10) (tl 20 :: 5 :: 70 :: 3 :: 80 :: 1000 :: [] : int)
-> fun (l:int list) : int -> if empty l then 10 else if hd l < 10 then fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (hd l) (tl l) else fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (10) (tl l) (tl 20 :: 5 :: 70 :: 3 :: 80 :: 1000 :: [] : int)
-> fun (l:int list) : int -> if empty l then 10 else if hd l < 10 then fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (hd l) (tl l) else fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (10) (tl l) (5 :: 70 :: 3 :: 80 :: 1000 :: [] : int)
-> if empty 5 :: 70 :: 3 :: 80 :: 1000 :: [] : int then 10 else if hd 5 :: 70 :: 3 :: 80 :: 1000 :: [] : int < 10 then fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (hd 5 :: 70 :: 3 :: 80 :: 1000 :: [] : int) (tl 5 :: 70 :: 3 :: 80 :: 1000 :: [] : int) else fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (10) (tl 5 :: 70 :: 3 :: 80 :: 1000 :: [] : int)
-> if false then 10 else if hd 5 :: 70 :: 3 :: 80 :: 1000 :: [] : int < 10 then fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (hd 5 :: 70 :: 3 :: 80 :: 1000 :: [] : int) (tl 5 :: 70 :: 3 :: 80 :: 1000 :: [] : int) else fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (10) (tl 5 :: 70 :: 3 :: 80 :: 1000 :: [] : int)
-> if 5 < 10 then fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (hd 5 :: 70 :: 3 :: 80 :: 1000 :: [] : int) (tl 5 :: 70 :: 3 :: 80 :: 1000 :: [] : int) else fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (10) (tl 5 :: 70 :: 3 :: 80 :: 1000 :: [] : int)
-> if true then fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (hd 5 :: 70 :: 3 :: 80 :: 1000 :: [] : int) (tl 5 :: 70 :: 3 :: 80 :: 1000 :: [] : int) else fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (10) (tl 5 :: 70 :: 3 :: 80 :: 1000 :: [] : int)
-> fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (5) (tl 5 :: 70 :: 3 :: 80 :: 1000 :: [] : int)
-> fun (l:int list) : int -> if empty l then 5 else if hd l < 5 then fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (hd l) (tl l) else fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (5) (tl l) (tl 5 :: 70 :: 3 :: 80 :: 1000 :: [] : int)
-> fun (l:int list) : int -> if empty l then 5 else if hd l < 5 then fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (hd l) (tl l) else fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (5) (tl l) (70 :: 3 :: 80 :: 1000 :: [] : int)
-> if empty 70 :: 3 :: 80 :: 1000 :: [] : int then 5 else if hd 70 :: 3 :: 80 :: 1000 :: [] : int < 5 then fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (hd 70 :: 3 :: 80 :: 1000 :: [] : int) (tl 70 :: 3 :: 80 :: 1000 :: [] : int) else fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (5) (tl 70 :: 3 :: 80 :: 1000 :: [] : int)
-> if false then 5 else if hd 70 :: 3 :: 80 :: 1000 :: [] : int < 5 then fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (hd 70 :: 3 :: 80 :: 1000 :: [] : int) (tl 70 :: 3 :: 80 :: 1000 :: [] : int) else fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (5) (tl 70 :: 3 :: 80 :: 1000 :: [] : int)
-> if 70 < 5 then fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (hd 70 :: 3 :: 80 :: 1000 :: [] : int) (tl 70 :: 3 :: 80 :: 1000 :: [] : int) else fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (5) (tl 70 :: 3 :: 80 :: 1000 :: [] : int)
-> if false then fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (hd 70 :: 3 :: 80 :: 1000 :: [] : int) (tl 70 :: 3 :: 80 :: 1000 :: [] : int) else fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (5) (tl 70 :: 3 :: 80 :: 1000 :: [] : int)
-> fun (l:int list) : int -> if empty l then 5 else if hd l < 5 then fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (hd l) (tl l) else fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (5) (tl l) (tl 70 :: 3 :: 80 :: 1000 :: [] : int)
-> fun (l:int list) : int -> if empty l then 5 else if hd l < 5 then fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (hd l) (tl l) else fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (5) (tl l) (3 :: 80 :: 1000 :: [] : int)
-> if empty 3 :: 80 :: 1000 :: [] : int then 5 else if hd 3 :: 80 :: 1000 :: [] : int < 5 then fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (hd 3 :: 80 :: 1000 :: [] : int) (tl 3 :: 80 :: 1000 :: [] : int) else fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (5) (tl 3 :: 80 :: 1000 :: [] : int)
-> if false then 5 else if hd 3 :: 80 :: 1000 :: [] : int < 5 then fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (hd 3 :: 80 :: 1000 :: [] : int) (tl 3 :: 80 :: 1000 :: [] : int) else fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (5) (tl 3 :: 80 :: 1000 :: [] : int)
-> if 3 < 5 then fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (hd 3 :: 80 :: 1000 :: [] : int) (tl 3 :: 80 :: 1000 :: [] : int) else fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (5) (tl 3 :: 80 :: 1000 :: [] : int)
-> if true then fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (hd 3 :: 80 :: 1000 :: [] : int) (tl 3 :: 80 :: 1000 :: [] : int) else fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (5) (tl 3 :: 80 :: 1000 :: [] : int)
-> fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (3) (tl 3 :: 80 :: 1000 :: [] : int)
-> fun (l:int list) : int -> if empty l then 3 else if hd l < 3 then fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (hd l) (tl l) else fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (3) (tl l) (tl 3 :: 80 :: 1000 :: [] : int)
-> fun (l:int list) : int -> if empty l then 3 else if hd l < 3 then fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (hd l) (tl l) else fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (3) (tl l) (80 :: 1000 :: [] : int)
-> if empty 80 :: 1000 :: [] : int then 3 else if hd 80 :: 1000 :: [] : int < 3 then fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (hd 80 :: 1000 :: [] : int) (tl 80 :: 1000 :: [] : int) else fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (3) (tl 80 :: 1000 :: [] : int)
-> if false then 3 else if hd 80 :: 1000 :: [] : int < 3 then fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (hd 80 :: 1000 :: [] : int) (tl 80 :: 1000 :: [] : int) else fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (3) (tl 80 :: 1000 :: [] : int)
-> if 80 < 3 then fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (hd 80 :: 1000 :: [] : int) (tl 80 :: 1000 :: [] : int) else fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (3) (tl 80 :: 1000 :: [] : int)
-> if false then fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (hd 80 :: 1000 :: [] : int) (tl 80 :: 1000 :: [] : int) else fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (3) (tl 80 :: 1000 :: [] : int)
-> fun (l:int list) : int -> if empty l then 3 else if hd l < 3 then fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (hd l) (tl l) else fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (3) (tl l) (tl 80 :: 1000 :: [] : int)
-> fun (l:int list) : int -> if empty l then 3 else if hd l < 3 then fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (hd l) (tl l) else fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (3) (tl l) (1000 :: [] : int)
-> if empty 1000 :: [] : int then 3 else if hd 1000 :: [] : int < 3 then fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (hd 1000 :: [] : int) (tl 1000 :: [] : int) else fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (3) (tl 1000 :: [] : int)
-> if false then 3 else if hd 1000 :: [] : int < 3 then fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (hd 1000 :: [] : int) (tl 1000 :: [] : int) else fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (3) (tl 1000 :: [] : int)
-> if 1000 < 3 then fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (hd 1000 :: [] : int) (tl 1000 :: [] : int) else fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (3) (tl 1000 :: [] : int)
-> if false then fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (hd 1000 :: [] : int) (tl 1000 :: [] : int) else fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (3) (tl 1000 :: [] : int)
-> fun (l:int list) : int -> if empty l then 3 else if hd l < 3 then fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (hd l) (tl l) else fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (3) (tl l) (tl 1000 :: [] : int)
-> fun (l:int list) : int -> if empty l then 3 else if hd l < 3 then fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (hd l) (tl l) else fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (3) (tl l) ([] : int)
-> if empty [] : int then 3 else if hd [] : int < 3 then fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (hd [] : int) (tl [] : int) else fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (3) (tl [] : int)
-> if true then 3 else if hd [] : int < 3 then fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (hd [] : int) (tl [] : int) else fix f (cur:int) : (int list -> int) -> fun (l:int list) : int -> if empty l then cur else if hd l < cur then f (hd l) (tl l) else f (cur) (tl l) (3) (tl [] : int)
-> 3
